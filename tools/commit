#!/bin/bash
# Create properly formatted commits for The Agency
#
# Usage:
#   ./tools/commit "short summary" --work-item REQUEST-jordan-0065 --stage impl
#   ./tools/commit "fix null handling" --work-item BUG-0042 --stage review
#   ./tools/commit "update README"  # No work item (simple commit)
#
# Format (with work item):
#   {WORK-ITEM} - {WORKSTREAM}/{AGENT} for {PRINCIPAL}: {SHORT SUMMARY}
#
#   {body}
#
#   Stage: {stage}
#   Generated-With: Claude Code
#   Co-Authored-By: Claude <noreply@anthropic.com>
#
# Format (without work item):
#   {WORKSTREAM}/{AGENT}: {SHORT SUMMARY}
#
#   {body}
#
#   Generated-With: Claude Code
#   Co-Authored-By: Claude <noreply@anthropic.com>
#
# Options:
#   --work-item, -w   Work item ID (REQUEST-jordan-0065, SPRINT-web-2026w03, etc.)
#   --stage, -s       Stage: impl, review, tests (required if work-item provided)
#   --body, -b        Detailed commit body
#   --principal, -p   Override principal (default: from config or work item)
#   --no-verify       Skip pre-commit hooks
#   --amend           Amend the previous commit (use carefully!)
#   --dry-run         Show what would be committed
#   --staged          Only commit staged changes (default: stage all)
#   --verbose         Show detailed output
#

set -euo pipefail

# Tool version
TOOL_VERSION="1.1.0-20260114-000001"

# Source log helper for tool tracking
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "commit" "agency-tool" "$@" 2>/dev/null) || true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Defaults
NO_VERIFY=false
AMEND=false
DRY_RUN=false
STAGED_ONLY=false
VERBOSE=false
WORK_ITEM=""
STAGE=""
BODY=""
PRINCIPAL_OVERRIDE=""
MESSAGE=""

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "commit $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            head -36 "$0" | tail -35 | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --no-verify)
            NO_VERIFY=true
            shift
            ;;
        --amend)
            AMEND=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --staged)
            STAGED_ONLY=true
            shift
            ;;
        --work-item|-w)
            WORK_ITEM="$2"
            shift 2
            ;;
        --stage|-s)
            STAGE="$2"
            shift 2
            ;;
        --body|-b)
            BODY="$2"
            shift 2
            ;;
        --principal|-p)
            PRINCIPAL_OVERRIDE="$2"
            shift 2
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 1
            ;;
        *)
            # Capture positional argument (message) and continue parsing
            if [ -z "$MESSAGE" ]; then
                MESSAGE="$1"
                shift
            else
                log_error "Unexpected argument: $1"
                exit 1
            fi
            ;;
    esac
done

# Main function
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    echo "commit [run: ${RUN_ID:-none}]"

    if [ -z "$MESSAGE" ]; then
        log_error "Commit message required"
        verbose_echo "Usage: ./tools/commit \"message\" --work-item WORK-ITEM --stage impl"
        trap - EXIT
        log_end "$RUN_ID" "failure" 1 0 "Missing commit message"
        exit 1
    fi

    # Validate: if work item provided, stage is required
    if [ -n "$WORK_ITEM" ] && [ -z "$STAGE" ]; then
        log_error "Stage required when work item is provided (--stage impl|review|tests)"
        trap - EXIT
        log_end "$RUN_ID" "failure" 1 0 "Missing stage"
        exit 1
    fi

    # Validate stage value
    if [ -n "$STAGE" ]; then
        case "$STAGE" in
            impl|review|tests) ;;
            *)
                log_error "Invalid stage: $STAGE (must be impl, review, or tests)"
                trap - EXIT
                log_end "$RUN_ID" "failure" 1 0 "Invalid stage"
                exit 1
                ;;
        esac
    fi

    # Try to detect workstream/agent from environment or current directory
    WORKSTREAM="${AGENCY_WORKSTREAM:-}"
    AGENT="${AGENCY_AGENT:-}"

    # If not set, try to infer from myclaude session marker
    if [ -z "$WORKSTREAM" ] || [ -z "$AGENT" ]; then
        # Check for session file
        SESSION_FILE="${HOME}/.claude/current-session"
        if [ -f "$SESSION_FILE" ]; then
            source "$SESSION_FILE" 2>/dev/null || true
        fi
    fi

    # Fallback: try to get from git branch name (e.g., feature/housekeeping-secret-service)
    if [ -z "$WORKSTREAM" ] || [ -z "$AGENT" ]; then
        BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        # Try pattern like "workstream/agent-description"
        if [[ "$BRANCH" =~ ^([a-z-]+)/([a-z-]+)- ]]; then
            WORKSTREAM="${BASH_REMATCH[1]}"
            AGENT="${BASH_REMATCH[2]}"
        fi
    fi

    # Final fallback: use "housekeeping/captain" as default
    WORKSTREAM="${WORKSTREAM:-housekeeping}"
    AGENT="${AGENT:-captain}"

    # Determine principal
    PRINCIPAL=""
    if [ -n "$PRINCIPAL_OVERRIDE" ]; then
        PRINCIPAL="$PRINCIPAL_OVERRIDE"
    elif [ -n "$WORK_ITEM" ]; then
        # Try to extract principal from work item (e.g., REQUEST-jordan-0065 -> jordan)
        if [[ "$WORK_ITEM" =~ ^[A-Z]+-([a-z]+)- ]]; then
            PRINCIPAL="${BASH_REMATCH[1]}"
        fi
    fi
    # Fallback: try environment or config
    if [ -z "$PRINCIPAL" ]; then
        PRINCIPAL="${AGENCY_PRINCIPAL:-${PRINCIPAL:-unknown}}"
    fi

    # Build the commit message
    # Format with work item: {WORK-ITEM} - {WORKSTREAM}/{AGENT} for {PRINCIPAL}: {MESSAGE}
    # Format without: {WORKSTREAM}/{AGENT}: {MESSAGE}
    if [ -n "$WORK_ITEM" ]; then
        FULL_MESSAGE="${WORK_ITEM} - ${WORKSTREAM}/${AGENT} for ${PRINCIPAL}: ${MESSAGE}"
    else
        FULL_MESSAGE="${WORKSTREAM}/${AGENT}: ${MESSAGE}"
    fi

    # Build the commit body with trailers
    COMMIT_BODY=""
    if [ -n "$BODY" ]; then
        COMMIT_BODY="${BODY}"$'\n\n'
    fi
    if [ -n "$STAGE" ]; then
        COMMIT_BODY="${COMMIT_BODY}Stage: ${STAGE}"$'\n'
    fi
    COMMIT_BODY="${COMMIT_BODY}Generated-With: Claude Code"$'\n'
    COMMIT_BODY="${COMMIT_BODY}Co-Authored-By: Claude <noreply@anthropic.com>"

    # Show preview (verbose only)
    log_step "Commit Preview"
    verbose_echo "---"
    verbose_echo -e "${GREEN}${FULL_MESSAGE}${NC}"
    verbose_echo ""
    verbose_echo "$COMMIT_BODY"
    verbose_echo "---"

    # Check for changes
    if [ "$AMEND" = false ]; then
        if [ "$STAGED_ONLY" = false ]; then
            # Check if there are any changes to commit
            if [ -z "$(git status --porcelain)" ]; then
                log_warn "Nothing to commit, working tree clean"
                trap - EXIT
                log_end "$RUN_ID" "success" 0 0 "Nothing to commit"
                exit 0
            fi
        else
            # Check if there are staged changes
            if [ -z "$(git diff --cached --name-only)" ]; then
                log_warn "No staged changes to commit"
                verbose_echo "Tip: Stage files with 'git add' or use without --staged to commit all"
                trap - EXIT
                log_end "$RUN_ID" "success" 0 0 "No staged changes"
                exit 0
            fi
        fi
    fi

    # Dry run - just show what would happen
    if [ "$DRY_RUN" = true ]; then
        echo "[dry-run]"
        echo "✓"

        trap - EXIT
        log_end "$RUN_ID" "success" 0 0 "Dry run: $FULL_MESSAGE"
        exit 0
    fi

    # Stage changes if not staged-only mode
    if [ "$STAGED_ONLY" = false ]; then
        log_step "Staging all changes"
        git add -A
    fi

    # Build git commit command
    GIT_CMD="git commit"

    if [ "$NO_VERIFY" = true ]; then
        GIT_CMD="$GIT_CMD --no-verify"
    fi

    if [ "$AMEND" = true ]; then
        GIT_CMD="$GIT_CMD --amend"
    fi

    # Execute commit
    log_step "Creating commit"
    COMMIT_OUTPUT=$($GIT_CMD -m "$FULL_MESSAGE" -m "$COMMIT_BODY" 2>&1)
    COMMIT_EXIT=$?

    if [ $COMMIT_EXIT -eq 0 ]; then
        COMMIT_HASH=$(git log -1 --format='%h')
        echo "Committed: $COMMIT_HASH"
        echo "✓"

        verbose_echo ""
        [[ "$VERBOSE" == "true" ]] && git log -1 --oneline

        trap - EXIT
        log_end "$RUN_ID" "success" 0 ${#COMMIT_OUTPUT} "Committed: $COMMIT_HASH - $MESSAGE"
    else
        echo "✗"
        trap - EXIT
        # Log verbose output to database for investigation
        log_end "$RUN_ID" "failure" "$COMMIT_EXIT" ${#COMMIT_OUTPUT} "Commit failed: $MESSAGE"
        # Only show error in verbose mode
        [[ "$VERBOSE" == "true" ]] && echo "$COMMIT_OUTPUT"
        exit $COMMIT_EXIT
    fi
}

main
