#!/bin/bash
# Create properly formatted commits for The Agency
#
# Usage:
#   ./tools/commit "feat: add encryption" REQUEST-jordan-0017
#   ./tools/commit "fix: handle null case" BUG-0042
#   ./tools/commit "docs: update README"  # No work item
#
# Format:
#   workstream/agent: message
#
#   WORK-ITEM-ID (if provided)
#   Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
#
# Options:
#   --no-verify    Skip pre-commit hooks
#   --amend        Amend the previous commit (use carefully!)
#   --dry-run      Show what would be committed
#   --staged       Only commit staged changes (default: stage all)
#   --verbose      Show detailed output
#

set -e

# Tool version
TOOL_VERSION="1.1.0-20260114-000001"

# Source log helper for tool tracking
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "commit" "agency-tool" "$@" 2>/dev/null) || true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Defaults
NO_VERIFY=false
AMEND=false
DRY_RUN=false
STAGED_ONLY=false
VERBOSE=false

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "commit $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            head -24 "$0" | tail -23 | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --no-verify)
            NO_VERIFY=true
            shift
            ;;
        --amend)
            AMEND=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --staged)
            STAGED_ONLY=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Get message and work item
MESSAGE="${1:-}"
WORK_ITEM="${2:-}"

# Main function
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    echo "commit [run: ${RUN_ID:-none}]"

    if [ -z "$MESSAGE" ]; then
        log_error "Commit message required"
        verbose_echo "Usage: ./tools/commit \"message\" [WORK-ITEM]"
        trap - EXIT
        log_end "$RUN_ID" "failure" 1 0 "Missing commit message"
        exit 1
    fi

    # Try to detect workstream/agent from environment or current directory
    WORKSTREAM="${AGENCY_WORKSTREAM:-}"
    AGENT="${AGENCY_AGENT:-}"

    # If not set, try to infer from myclaude session marker
    if [ -z "$WORKSTREAM" ] || [ -z "$AGENT" ]; then
        # Check for session file
        SESSION_FILE="${HOME}/.claude/current-session"
        if [ -f "$SESSION_FILE" ]; then
            source "$SESSION_FILE" 2>/dev/null || true
        fi
    fi

    # Fallback: try to get from git branch name (e.g., feature/housekeeping-secret-service)
    if [ -z "$WORKSTREAM" ] || [ -z "$AGENT" ]; then
        BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        # Try pattern like "workstream/agent-description"
        if [[ "$BRANCH" =~ ^([a-z-]+)/([a-z-]+)- ]]; then
            WORKSTREAM="${BASH_REMATCH[1]}"
            AGENT="${BASH_REMATCH[2]}"
        fi
    fi

    # Final fallback: use "housekeeping/captain" as default
    WORKSTREAM="${WORKSTREAM:-housekeeping}"
    AGENT="${AGENT:-captain}"

    # Build the commit message
    PREFIX="${WORKSTREAM}/${AGENT}"
    FULL_MESSAGE="${PREFIX}: ${MESSAGE}"

    # Add work item and co-author
    BODY=""
    if [ -n "$WORK_ITEM" ]; then
        BODY="${WORK_ITEM}"$'\n'
    fi
    BODY="${BODY}Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"

    # Show preview (verbose only)
    log_step "Commit Preview"
    verbose_echo "---"
    verbose_echo -e "${GREEN}${FULL_MESSAGE}${NC}"
    verbose_echo ""
    verbose_echo "$BODY"
    verbose_echo "---"

    # Check for changes
    if [ "$AMEND" = false ]; then
        if [ "$STAGED_ONLY" = false ]; then
            # Check if there are any changes to commit
            if [ -z "$(git status --porcelain)" ]; then
                log_warn "Nothing to commit, working tree clean"
                trap - EXIT
                log_end "$RUN_ID" "success" 0 0 "Nothing to commit"
                exit 0
            fi
        else
            # Check if there are staged changes
            if [ -z "$(git diff --cached --name-only)" ]; then
                log_warn "No staged changes to commit"
                verbose_echo "Tip: Stage files with 'git add' or use without --staged to commit all"
                trap - EXIT
                log_end "$RUN_ID" "success" 0 0 "No staged changes"
                exit 0
            fi
        fi
    fi

    # Dry run - just show what would happen
    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would commit: $FULL_MESSAGE"

        if [ "$STAGED_ONLY" = false ]; then
            verbose_echo "[DRY RUN] Would stage all changes:"
            [[ "$VERBOSE" == "true" ]] && git status --short
        else
            verbose_echo "[DRY RUN] Would commit staged changes:"
            [[ "$VERBOSE" == "true" ]] && git diff --cached --name-only
        fi

        if [ "$NO_VERIFY" = true ]; then
            verbose_echo "[DRY RUN] Would skip pre-commit hooks"
        fi

        if [ "$AMEND" = true ]; then
            verbose_echo "[DRY RUN] Would amend previous commit"
        fi

        trap - EXIT
        log_end "$RUN_ID" "success" 0 0 "Dry run complete"
        exit 0
    fi

    # Stage changes if not staged-only mode
    if [ "$STAGED_ONLY" = false ]; then
        log_step "Staging all changes"
        git add -A
    fi

    # Build git commit command
    GIT_CMD="git commit"

    if [ "$NO_VERIFY" = true ]; then
        GIT_CMD="$GIT_CMD --no-verify"
    fi

    if [ "$AMEND" = true ]; then
        GIT_CMD="$GIT_CMD --amend"
    fi

    # Execute commit
    log_step "Creating commit"
    if $GIT_CMD -m "$FULL_MESSAGE" -m "$BODY" >/dev/null 2>&1; then
        COMMIT_HASH=$(git log -1 --format='%h')
        echo "Committed: $COMMIT_HASH"

        verbose_echo ""
        [[ "$VERBOSE" == "true" ]] && git log -1 --oneline

        trap - EXIT
        log_end "$RUN_ID" "success" 0 0 "Committed: $COMMIT_HASH - $MESSAGE"
    else
        # Re-run without suppressing output to show the error
        if ! $GIT_CMD -m "$FULL_MESSAGE" -m "$BODY"; then
            COMMIT_EXIT=$?
            log_error "Commit failed"
            trap - EXIT
            log_end "$RUN_ID" "failure" "$COMMIT_EXIT" 0 "Commit failed: $MESSAGE"
            exit $COMMIT_EXIT
        fi
    fi
}

main
