#!/bin/bash
# Create properly formatted tags for work items and releases
#
# Usage:
#   ./tools/tag REQUEST-jordan-0017 impl      # REQUEST-jordan-0017-impl
#   ./tools/tag REQUEST-jordan-0017 review    # REQUEST-jordan-0017-review
#   ./tools/tag REQUEST-jordan-0017 tests     # REQUEST-jordan-0017-tests
#   ./tools/tag REQUEST-jordan-0017 complete  # REQUEST-jordan-0017-complete
#   ./tools/tag release 0.6.0                 # v0.6.0
#   ./tools/tag release 0.6.0 rc1             # v0.6.0-rc1
#
# Options:
#   --push, -p    Push tag to remote after creating
#   --message, -m Custom tag message
#   --dry-run     Show what would be done without doing it
#   --list        List tags for a work item
#
# Valid stages: impl, review, tests, complete

set -e

TOOL_VERSION="1.1.0-20260114-000002"

# Source log helper for tool tracking
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Defaults
VERBOSE=false

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Valid stages for work items
VALID_STAGES="impl review tests complete"

# Parse options
PUSH=false
DRY_RUN=false
LIST=false
MESSAGE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "tag $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            head -20 "$0" | tail -19 | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        --push|-p)
            PUSH=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --list)
            LIST=true
            shift
            ;;
        --message|-m)
            MESSAGE="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# List mode
if [ "$LIST" = true ]; then
    PATTERN="${1:-}"
    if [ -z "$PATTERN" ]; then
        log_error "Provide a work item pattern to list tags"
        echo "Usage: ./tools/tag --list REQUEST-jordan-0017"
        exit 1
    fi
    echo "Tags matching $PATTERN:"
    git tag -l "${PATTERN}*" | sort -V
    exit 0
fi

# Require at least 2 arguments
if [ $# -lt 2 ]; then
    log_error "Missing arguments"
    echo "Usage: ./tools/tag <work-item> <stage> [--verbose]"
    echo "       ./tools/tag release <version> [suffix] [--verbose]"
    echo ""
    echo "Examples:"
    echo "  ./tools/tag REQUEST-jordan-0017 impl"
    echo "  ./tools/tag release 0.6.0"
    echo "  ./tools/tag release 0.6.0 rc1"
    exit 1
fi

ITEM="$1"
STAGE="$2"
SUFFIX="${3:-}"

# Main function
main() {
    # Trap unexpected exits
    trap 'log_end "$LOG_RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    echo "tag [run: ${LOG_RUN_ID:-none}]"

    # Start logging
    LOG_RUN_ID=""
    if type log_start &>/dev/null; then
        LOG_RUN_ID=$(log_start "tag" "agency-tool" "$ITEM" "$STAGE" "$SUFFIX")
    fi

    # Determine tag format
    if [ "$ITEM" = "release" ]; then
        # Release tag
        VERSION="$STAGE"
        if [ -n "$SUFFIX" ]; then
            TAG_NAME="v${VERSION}-${SUFFIX}"
        else
            TAG_NAME="v${VERSION}"
        fi

        # Validate version format (semver)
        if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            log_error "Invalid version format. Use semver (e.g., 0.6.0)"
            trap - EXIT
            log_end "$LOG_RUN_ID" "failure" "1" "0" "Invalid version format"
            exit 1
        fi

        DEFAULT_MESSAGE="Release ${TAG_NAME}"
    else
        # Work item tag (REQUEST, BUG, etc.)

        # Validate stage
        if ! echo "$VALID_STAGES" | grep -qw "$STAGE"; then
            log_error "Invalid stage '$STAGE'"
            echo "Valid stages: $VALID_STAGES"
            trap - EXIT
            log_end "$LOG_RUN_ID" "failure" "1" "0" "Invalid stage"
            exit 1
        fi

        TAG_NAME="${ITEM}-${STAGE}"
        DEFAULT_MESSAGE="${ITEM} - ${STAGE} phase complete"
    fi

    # Use custom message or default
    TAG_MESSAGE="${MESSAGE:-$DEFAULT_MESSAGE}"

    # Check if tag already exists
    if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
        log_warn "Tag '$TAG_NAME' already exists"
        read -p "Delete and recreate? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if [ "$DRY_RUN" = true ]; then
                verbose_echo "[DRY RUN] Would delete tag: $TAG_NAME"
            else
                git tag -d "$TAG_NAME"
                if [ "$PUSH" = true ]; then
                    git push origin ":refs/tags/$TAG_NAME" 2>/dev/null || true
                fi
            fi
        else
            echo "Aborted."
            trap - EXIT
            log_end "$LOG_RUN_ID" "failure" "0" "0" "User aborted"
            exit 1
        fi
    fi

    # Create the tag
    if [ "$DRY_RUN" = true ]; then
        verbose_echo "[DRY RUN] Would create tag: $TAG_NAME"
        verbose_echo "[DRY RUN] Message: $TAG_MESSAGE"
        if [ "$PUSH" = true ]; then
            verbose_echo "[DRY RUN] Would push to remote"
        fi
        # End logging for dry run
        trap - EXIT
        if type log_end &>/dev/null && [[ -n "$LOG_RUN_ID" ]]; then
            log_end "$LOG_RUN_ID" "success" "0" "0" "Dry run: $TAG_NAME"
        fi
    else
        git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
        echo "Created tag: $TAG_NAME"

        if [ "$PUSH" = true ]; then
            git push origin "$TAG_NAME"
            log_info "Pushed tag to remote"
        else
            log_warn "Tip: Use --push to push to remote, or run: git push origin $TAG_NAME"
        fi

        # End logging
        trap - EXIT
        if type log_end &>/dev/null && [[ -n "$LOG_RUN_ID" ]]; then
            log_end "$LOG_RUN_ID" "success" "0" "0" "Created tag: $TAG_NAME"
        fi
    fi
}

main
