#!/bin/bash
# Tool: collaboration-respond
# Purpose: Respond to an inter-agent collaboration request
# Usage: ./tools/collaboration-respond "path/to/collaboration-file.md" "response text"
# Example: ./tools/collaboration-respond "claude/agents/collaboration/FROM-web-web-COLLABORATE-0001-2025-12-30.md" "I reviewed the design and have some suggestions..."

set -euo pipefail

# Tool version
TOOL_VERSION="1.0.1-20260114-000002"

# Defaults
VERBOSE=false

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi

# Version check
if [[ "${1:-}" == "--version" || "${1:-}" == "-v" ]]; then
    echo "collaboration-respond $TOOL_VERSION"
    exit 0
fi

# Parse flags
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help|-h)
            echo "Usage: ./tools/collaboration-respond [--verbose] \"path/to/collaboration-file.md\" \"response text\""
            echo "Example: ./tools/collaboration-respond \"claude/agents/collaboration/FROM-web-web-COLLABORATE-0001-2025-12-30.md\" \"I reviewed the design and have some suggestions...\""
            echo ""
            echo "Options:"
            echo "  --verbose    Show detailed output"
            echo "  --version    Show tool version"
            echo "  --help       Show this help"
            exit 0
            ;;
        *)
            break
            ;;
    esac
done

# Find repo root
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$REPO_ROOT"

# Auto-load .env.local if it exists
if [[ -f ".env.local" ]]; then
  set -a
  source .env.local
  set +a
fi

# Cross-platform sed -i (macOS vs Linux)
sed_i() {
  if [[ "$(uname)" == "Darwin" ]]; then
    sed -i '' "$@"
  else
    sed -i "$@"
  fi
}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Validate arguments
if [[ $# -lt 2 ]]; then
  echo "Usage: ./tools/collaboration-respond [--verbose] \"path/to/collaboration-file.md\" \"response text\""
  echo "Example: ./tools/collaboration-respond \"claude/agents/collaboration/FROM-web-web-COLLABORATE-0001-2025-12-30.md\" \"I reviewed the design and have some suggestions...\""
  exit 1
fi

COLLAB_FILE="$1"
RESPONSE_TEXT="$2"

# Main function
main() {
    # Trap unexpected exits
    trap 'if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then log_end "$RUN_ID" "failure" $? 0 "Unexpected exit"; fi' EXIT

    echo "collaboration-respond [run: ${RUN_ID:-none}]"

    RUN_ID=$(log_start "collaboration-respond" "agency-tool" "$@" 2>/dev/null) || true

    # Validate file exists
    if [[ ! -f "$COLLAB_FILE" ]]; then
      log_error "File not found: $COLLAB_FILE"
      trap - EXIT
      if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
          log_end "$RUN_ID" "failure" "1" "0" "File not found"
      fi
      exit 1
    fi

    # Get current timestamp
    TIMESTAMP=$("$SCRIPT_DIR/now" 2>/dev/null || date "+%Y-%m-%d %H:%M:%S %Z")

    # Get agent name for attribution
    RESPONDER_AGENT=$("$SCRIPT_DIR/agentname" 2>/dev/null || echo "unknown")
    RESPONDER_WORKSTREAM=$("$SCRIPT_DIR/workstream" 2>/dev/null || echo "unknown")
    COMMIT_PREFIX=$("$SCRIPT_DIR/commit-prefix" 2>/dev/null || echo "unknown/unknown:")

    # Extract COLLABORATE ID from filename for commit message
    COLLAB_ID=$(basename "$COLLAB_FILE" | grep -oE 'COLLABORATE-[0-9]+')

    # Function to handle merge conflicts
    handle_merge_conflict() {
      log_info "Merge conflict detected. Attempting to resolve..."
      # For collaboration files, prefer remote version and fail - user needs to re-pull and retry
      log_error "Remote has been updated. Please pull latest changes and retry your response."
      git merge --abort 2>/dev/null || true
      trap - EXIT
      if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
          log_end "$RUN_ID" "failure" "1" "0" "Merge conflict - remote updated"
      fi
      exit 1
    }

    # Step 1: Pull latest
    log_step "Pulling latest changes..."
    git pull --rebase 2>/dev/null || {
      # If rebase fails due to conflicts, abort and try regular pull
      git rebase --abort 2>/dev/null || true
      git pull || {
        # If regular pull also has conflicts, handle them
        if git diff --name-only --diff-filter=U | grep -q "$(dirname "$COLLAB_FILE")"; then
          handle_merge_conflict
        fi
      }
    }

    # Step 2: Check if already responded
    if grep -q "## Response" "$COLLAB_FILE" && ! grep -q "(To be filled by target agent" "$COLLAB_FILE"; then
      log_warn "This collaboration request already has a response."
      verbose_echo "Adding additional response..."
    fi

    # Step 3: Update status to "Responded"
    log_step "Updating collaboration status..."
    sed_i 's/\*\*Status:\*\* Open/\*\*Status:\*\* Responded/' "$COLLAB_FILE"

    # Step 4: Replace the response section
    # Find line number of "## Response" section
    RESPONSE_LINE=$(grep -n "^## Response" "$COLLAB_FILE" | cut -d: -f1)

    if [[ -z "$RESPONSE_LINE" ]]; then
      log_error "Could not find '## Response' section in file"
      trap - EXIT
      if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
          log_end "$RUN_ID" "failure" "1" "0" "Missing Response section"
      fi
      exit 1
    fi

    # Create temporary file with updated response
    HEAD_LINES=$((RESPONSE_LINE))
    head -n "$HEAD_LINES" "$COLLAB_FILE" > "${COLLAB_FILE}.tmp"

    cat >> "${COLLAB_FILE}.tmp" << EOF

**Responded by:** ${RESPONDER_AGENT} (${RESPONDER_WORKSTREAM})
**Date:** ${TIMESTAMP}

${RESPONSE_TEXT}

---

**Note:** Use \`./tools/collaboration-respond "${COLLAB_FILE}" "additional response"\` to add more responses.
EOF

    # Replace original file
    mv "${COLLAB_FILE}.tmp" "$COLLAB_FILE"

    verbose_echo "Updated collaboration request with response"

    # Step 5: Stage and commit
    log_step "Committing response..."
    git add "$COLLAB_FILE"
    COMMIT_MSG="$COMMIT_PREFIX chore: respond to ${COLLAB_ID}

Response from ${RESPONDER_AGENT} (${RESPONDER_WORKSTREAM})

${RESPONSE_TEXT}

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"

    git commit -m "$COMMIT_MSG

[skip ci]" || {
      log_error "Nothing to commit (response may already exist)"
      trap - EXIT
      if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
          log_end "$RUN_ID" "success" "0" "0" "Nothing to commit"
      fi
      exit 0
    }

    # Step 6: Push using sync tool
    log_step "Syncing changes..."
    "$SCRIPT_DIR/sync" || {
      log_error "Sync failed"
      trap - EXIT
      if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
          log_end "$RUN_ID" "failure" "1" "0" "Sync failed"
      fi
      exit 1
    }

    echo ""
    echo "Successfully responded to collaboration request:"
    echo "  File: ${COLLAB_FILE}"
    echo "  Responder: ${RESPONDER_AGENT} (${RESPONDER_WORKSTREAM})"
    echo "  Status: Responded"

    trap - EXIT
    if type log_end &>/dev/null && [[ -n "$RUN_ID" ]]; then
        log_end "$RUN_ID" "success" "0" "0" "Response to ${COLLAB_ID}"
    fi
}

main
