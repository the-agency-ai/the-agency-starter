#!/bin/bash
# figma-extract - Extract design tokens from Figma via API
#
# Usage:
#   ./tools/figma-extract <file-key> --name=<brand> --version=<version>
#   ./tools/figma-extract abc123xyz --name=acme --version=001
#
# Prerequisites:
#   1. Store Figma token: ./tools/secret create figma-token --type=api_key --service=Figma
#   2. Get file key from Figma URL: figma.com/file/FILE_KEY/...
#
# This tool:
#   1. Fetches file data from Figma API
#   2. Extracts color, typography, and effect styles
#   3. Creates design system in claude/knowledge/design-systems/<name>-<version>/
#   4. Generates Tailwind config

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source log helper for tool tracking
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi

# Start logging
RUN_ID=$(log_start "figma-extract" "agency-tool" "$@" 2>/dev/null) || true

# Tool version
TOOL_VERSION="1.2.0-20260114-000004"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Helper function: Convert RGBA (0-1 range) to hex
rgba_to_hex() {
    local r=$1 g=$2 b=$3
    # Convert 0-1 range to 0-255 and format as hex
    printf "#%02X%02X%02X" \
        $(echo "$r * 255" | bc | cut -d. -f1) \
        $(echo "$g * 255" | bc | cut -d. -f1) \
        $(echo "$b * 255" | bc | cut -d. -f1)
}

# Helper function: Extract unique colors from document JSON
extract_embedded_colors() {
    local json_file=$1
    local output_file=$2

    # Extract all SOLID color fills, convert to hex, deduplicate
    grep -o '"type":"SOLID","color":{"r":[0-9.]*,"g":[0-9.]*,"b":[0-9.]*' "$json_file" 2>/dev/null | \
        sed 's/.*"r":\([0-9.]*\),"g":\([0-9.]*\),"b":\([0-9.]*\)/\1 \2 \3/' | \
        sort -u | \
        while read r g b; do
            # Convert to hex
            hex=$(printf "#%02X%02X%02X" \
                $(echo "$r * 255" | bc | cut -d. -f1) \
                $(echo "$g * 255" | bc | cut -d. -f1) \
                $(echo "$b * 255" | bc | cut -d. -f1))
            echo "$hex"
        done | sort -u > "$output_file"
}

# Helper function: Extract unique fonts from document JSON
extract_embedded_fonts() {
    local json_file=$1
    local output_file=$2

    # Extract fontFamily values with counts
    grep -o '"fontFamily":"[^"]*"' "$json_file" 2>/dev/null | \
        cut -d'"' -f4 | \
        sort | uniq -c | sort -rn > "$output_file"
}

# Defaults
VERBOSE=false

# Help
show_help() {
    echo "figma-extract - Extract design tokens from Figma via API"
    echo ""
    echo "Usage:"
    echo "  ./tools/figma-extract <file-key> --name=<brand> --version=<version>"
    echo ""
    echo "Arguments:"
    echo "  file-key     Figma file key (from URL: figma.com/file/FILE_KEY/...)"
    echo ""
    echo "Options:"
    echo "  --name=<brand>      Brand/project name (e.g., acme)"
    echo "  --version=<version> Version number (e.g., 001)"
    echo "  --dry-run           Show what would be extracted without creating files"
    echo "  --help, -h          Show this help"
    echo "  --version, -v       Show version"
    echo "  --verbose           Enable verbose logging"
    echo ""
    echo "Prerequisites:"
    echo "  1. Store Figma token:"
    echo "     ./tools/secret create figma-token --type=api_key --service=Figma"
    echo ""
    echo "  2. Get file key from Figma URL:"
    echo "     https://www.figma.com/file/FILE_KEY/Project-Name"
    echo ""
    echo "Examples:"
    echo "  ./tools/figma-extract abc123xyz --name=acme --version=001"
    echo "  ./tools/figma-extract abc123xyz --name=myproject --version=002 --dry-run"
    echo ""
    echo "Hybrid Workflow (Recommended for comprehensive extraction):"
    echo ""
    echo "  The Figma API only returns 'published' library styles. For designs"
    echo "  with unpublished styles, use the hybrid PDF workflow:"
    echo ""
    echo "  1. Run this tool to create the structure:"
    echo "     ./tools/figma-extract abc123xyz --name=acme --version=001"
    echo ""
    echo "  2. In Figma, export design documentation pages as PDFs:"
    echo "     - Select the Colors/Typography/Effects pages"
    echo "     - File > Export frames to PDF"
    echo "     - Save to: <design-system>/source/"
    echo ""
    echo "  3. Ask Claude Code to read the PDFs and populate the markdown files:"
    echo "     'Read the PDFs in source/ and update colors.md with the values'"
    echo ""
    echo "  This captures the designer's organized documentation rather than"
    echo "  just raw style data from the API."
}

# Parse arguments
FILE_KEY=""
BRAND_NAME=""
VERSION=""
DRY_RUN=false

for arg in "$@"; do
    case $arg in
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "figma-extract $TOOL_VERSION"
            exit 0
            ;;
        --name=*)
            BRAND_NAME="${arg#*=}"
            ;;
        --version=*)
            VERSION="${arg#*=}"
            ;;
        --dry-run)
            DRY_RUN=true
            ;;
        --verbose)
            VERBOSE=true
            ;;
        --*)
            log_error "Unknown option: $arg"
            exit 1
            ;;
        *)
            if [[ -z "$FILE_KEY" ]]; then
                FILE_KEY="$arg"
            fi
            ;;
    esac
done

# Validate arguments
if [[ -z "$FILE_KEY" ]]; then
    log_error "Missing required argument: file-key"
    echo ""
    show_help
    exit 1
fi

if [[ -z "$BRAND_NAME" ]]; then
    log_error "Missing required option: --name=<brand>"
    exit 1
fi

if [[ -z "$VERSION" ]]; then
    log_error "Missing required option: --version=<version>"
    exit 1
fi

# Get Figma token from secret service
log_step "Fetching Figma API token..."
FIGMA_TOKEN=$("$PROJECT_ROOT/tools/secret" get figma-token 2>/dev/null) || true

if [[ -z "$FIGMA_TOKEN" ]]; then
    log_error "Figma token not found in Secret Service"
    echo ""
    echo "To set up Figma API access:"
    echo "  1. Go to Figma > Account Settings > Personal Access Tokens"
    echo "  2. Generate a new token"
    echo "  3. Store it: ./tools/secret create figma-token --type=api_key --service=Figma"
    log_end "$RUN_ID" "failure" "1" "0" "No Figma token" 2>/dev/null || true
    exit 1
fi
log_info "Token retrieved from Secret Service"

# Set up output directory
SYSTEM_NAME="${BRAND_NAME}-${VERSION}"
OUTPUT_DIR="$PROJECT_ROOT/claude/knowledge/design-systems/$SYSTEM_NAME"

if [[ -d "$OUTPUT_DIR" && "$DRY_RUN" != "true" ]]; then
    log_error "Design system already exists: $OUTPUT_DIR"
    echo ""
    echo "Options:"
    echo "  1. Use a different version number"
    echo "  2. Delete existing directory: rm -rf $OUTPUT_DIR"
    exit 1
fi

main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    echo "figma-extract [run: ${RUN_ID:-none}]"
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  Figma Design System Extraction${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "  File Key:    $FILE_KEY"
    echo "  Brand:       $BRAND_NAME"
    echo "  Version:     $VERSION"
    echo "  Output:      $OUTPUT_DIR"
    echo ""

# Fetch file data from Figma API
log_step "Fetching file data from Figma API..."

FIGMA_API="https://api.figma.com/v1"
TEMP_DIR=$(mktemp -d)
FILE_DATA="$TEMP_DIR/file.json"
STYLES_DATA="$TEMP_DIR/styles.json"

# Fetch file metadata and document (depth=3 for embedded colors/fonts)
log_info "Fetching document with depth=3 for embedded data..."
curl -s -H "X-Figma-Token: $FIGMA_TOKEN" \
    "$FIGMA_API/files/$FILE_KEY?depth=3" > "$FILE_DATA"

# Check for API errors
if grep -q '"err"' "$FILE_DATA" 2>/dev/null; then
    ERROR_MSG=$(grep -o '"message":"[^"]*"' "$FILE_DATA" | head -1 | cut -d'"' -f4)
    log_error "Figma API error: $ERROR_MSG"
    rm -rf "$TEMP_DIR"
    log_end "$RUN_ID" "failure" "1" "0" "API error: $ERROR_MSG" 2>/dev/null || true
    exit 1
fi

# Extract file name
FILE_NAME=$(grep -o '"name":"[^"]*"' "$FILE_DATA" | head -1 | cut -d'"' -f4)
log_info "File: $FILE_NAME"

# Fetch styles
curl -s -H "X-Figma-Token: $FIGMA_TOKEN" \
    "$FIGMA_API/files/$FILE_KEY/styles" > "$STYLES_DATA"

log_info "Data fetched successfully"

if [[ "$DRY_RUN" == "true" ]]; then
    echo ""
    log_warn "DRY RUN - Showing what would be extracted"
    echo ""

    # Count published styles
    COLOR_COUNT=$(grep -c '"style_type":"FILL"' "$STYLES_DATA" 2>/dev/null) || COLOR_COUNT=0
    TEXT_COUNT=$(grep -c '"style_type":"TEXT"' "$STYLES_DATA" 2>/dev/null) || TEXT_COUNT=0
    EFFECT_COUNT=$(grep -c '"style_type":"EFFECT"' "$STYLES_DATA" 2>/dev/null) || EFFECT_COUNT=0

    # Count embedded colors/fonts from document
    EMBEDDED_COLORS_FILE="$TEMP_DIR/embedded-colors.txt"
    EMBEDDED_FONTS_FILE="$TEMP_DIR/embedded-fonts.txt"
    extract_embedded_colors "$FILE_DATA" "$EMBEDDED_COLORS_FILE"
    extract_embedded_fonts "$FILE_DATA" "$EMBEDDED_FONTS_FILE"
    EMBEDDED_COLOR_COUNT=$(wc -l < "$EMBEDDED_COLORS_FILE" | tr -d ' ')
    EMBEDDED_FONT_COUNT=$(wc -l < "$EMBEDDED_FONTS_FILE" | tr -d ' ')

    echo "Published Styles (from Figma library):"
    echo "  - $COLOR_COUNT color styles"
    echo "  - $TEXT_COUNT text styles"
    echo "  - $EFFECT_COUNT effect styles"
    echo ""
    echo "Embedded Design Data (from document):"
    echo "  - $EMBEDDED_COLOR_COUNT unique colors"
    echo "  - $EMBEDDED_FONT_COUNT fonts"
    if [[ $EMBEDDED_FONT_COUNT -gt 0 ]]; then
        echo ""
        echo "  Top fonts:"
        head -5 "$EMBEDDED_FONTS_FILE" | while read count font; do
            printf "    %6d uses: %s\n" "$count" "$font"
        done
    fi
    echo ""
    echo "Would create: $OUTPUT_DIR/"

    rm -rf "$TEMP_DIR"
    log_end "$RUN_ID" "success" "0" "0" "Dry run complete" 2>/dev/null || true
    exit 0
fi

# Create output directory
log_step "Creating design system directory..."
mkdir -p "$OUTPUT_DIR/source"

# Copy raw data for reference
cp "$FILE_DATA" "$OUTPUT_DIR/source/figma-file.json"
cp "$STYLES_DATA" "$OUTPUT_DIR/source/figma-styles.json"

# Extract and process colors
log_step "Extracting colors..."
COLORS_MD="$OUTPUT_DIR/colors.md"
COLORS_JSON="$OUTPUT_DIR/source/colors.json"
EMBEDDED_COLORS_FILE="$TEMP_DIR/embedded-colors.txt"

# Extract embedded colors from document
extract_embedded_colors "$FILE_DATA" "$EMBEDDED_COLORS_FILE"
EMBEDDED_COLOR_COUNT=$(wc -l < "$EMBEDDED_COLORS_FILE" | tr -d ' ')

# Count published color styles
COLOR_COUNT=$(grep -c '"style_type":"FILL"' "$STYLES_DATA" 2>/dev/null) || COLOR_COUNT=0
log_info "Found $COLOR_COUNT published color styles"
log_info "Found $EMBEDDED_COLOR_COUNT unique colors in document"

# Generate colors.md with extracted data
cat > "$COLORS_MD" << EOF
# Colors

Extracted from Figma design system.

## Summary

| Source | Count |
|--------|-------|
| Published Styles | $COLOR_COUNT |
| Embedded (document) | $EMBEDDED_COLOR_COUNT |

## Extracted Colors

The following unique colors were found in the document:

| Hex | Preview | Name (to assign) |
|-----|---------|------------------|
EOF

# Add extracted colors to markdown
while read hex; do
    echo "| \`$hex\` | ![](https://via.placeholder.com/20/$hex/000000?text=+) | |" >> "$COLORS_MD"
done < "$EMBEDDED_COLORS_FILE"

# Save colors as JSON
echo "[" > "$COLORS_JSON"
first=true
while read hex; do
    if [[ "$first" == "true" ]]; then
        first=false
    else
        echo "," >> "$COLORS_JSON"
    fi
    printf '  {"hex": "%s", "name": ""}' "$hex" >> "$COLORS_JSON"
done < "$EMBEDDED_COLORS_FILE"
echo "" >> "$COLORS_JSON"
echo "]" >> "$COLORS_JSON"

cat >> "$COLORS_MD" << 'EOF'

## Color Organization Guide

Organize colors into categories:

### Neutrals
(Move black, white, gray colors here)

### Brand Colors
(Move primary brand colors here)

### Semantic Colors
(Map to: success, warning, error, info)

---

**Next Steps:**
1. Assign names to each color above
2. Organize into categories
3. Update tailwind-config.md with named colors
EOF

# Extract and process typography
log_step "Extracting typography..."
TYPOGRAPHY_MD="$OUTPUT_DIR/typography.md"
EMBEDDED_FONTS_FILE="$TEMP_DIR/embedded-fonts.txt"

# Extract embedded fonts from document
extract_embedded_fonts "$FILE_DATA" "$EMBEDDED_FONTS_FILE"
EMBEDDED_FONT_COUNT=$(wc -l < "$EMBEDDED_FONTS_FILE" | tr -d ' ')

# Count published text styles
TEXT_COUNT=$(grep -c '"style_type":"TEXT"' "$STYLES_DATA" 2>/dev/null) || TEXT_COUNT=0
log_info "Found $TEXT_COUNT published text styles"
log_info "Found $EMBEDDED_FONT_COUNT fonts in document"

# Generate typography.md with extracted data
cat > "$TYPOGRAPHY_MD" << EOF
# Typography

Extracted from Figma design system.

## Summary

| Source | Count |
|--------|-------|
| Published Text Styles | $TEXT_COUNT |
| Fonts in Document | $EMBEDDED_FONT_COUNT |

## Font Families

The following fonts are used in the document:

| Font | Usage Count | Notes |
|------|-------------|-------|
EOF

# Add extracted fonts to markdown
while read count font; do
    echo "| $font | $count | |" >> "$TYPOGRAPHY_MD"
done < "$EMBEDDED_FONTS_FILE"

cat >> "$TYPOGRAPHY_MD" << 'EOF'

## Text Styles

Define text styles based on document analysis:

| Style | Font | Size | Weight | Line Height | Tailwind Class |
|-------|------|------|--------|-------------|----------------|
| Heading 1 | | | | | `text-heading-1` |
| Heading 2 | | | | | `text-heading-2` |
| Heading 3 | | | | | `text-heading-3` |
| Body | | | | | `text-body` |
| Body Small | | | | | `text-body-sm` |
| Caption | | | | | `text-caption` |

---

**Next Steps:**
1. Export typography page from Figma as PDF
2. Ask Claude to read the PDF and fill in the table above
3. Or manually inspect source/figma-file.json for fontSize/fontWeight values

## Font Setup

Ensure fonts are available in your project:

```bash
# For web projects, add to your CSS or HTML:
# Google Fonts (if applicable)
# Local font files in /public/fonts/
```
EOF

# Extract and process effects
log_step "Extracting effects..."
EFFECTS_MD="$OUTPUT_DIR/effects.md"

cat > "$EFFECTS_MD" << 'EOF'
# Effects

Extracted from Figma design system.

## Shadow Styles

| Name | Type | Offset | Blur | Color |
|------|------|--------|------|-------|
EOF

# Count effect styles
EFFECT_COUNT=$(grep -c '"style_type":"EFFECT"' "$STYLES_DATA" 2>/dev/null) || EFFECT_COUNT=0
log_info "Found $EFFECT_COUNT effect styles"

if [[ $EFFECT_COUNT -gt 0 ]]; then
    echo "" >> "$EFFECTS_MD"
    echo "*$EFFECT_COUNT effect styles found in Figma. See source/figma-styles.json for raw data.*" >> "$EFFECTS_MD"
fi

# Create spacing.md (placeholder - spacing must be inferred from components)
log_step "Creating spacing template..."
cat > "$OUTPUT_DIR/spacing.md" << 'EOF'
# Spacing

Inferred from Figma components.

## Spacing Scale

| Token | Value | Usage |
|-------|-------|-------|
| xs | 4px | Tight spacing |
| sm | 8px | Small gaps |
| md | 16px | Default spacing |
| lg | 24px | Section spacing |
| xl | 32px | Large sections |
| 2xl | 48px | Page sections |

**Note:** Review Figma components to identify actual spacing scale.
EOF

# Create assets.md
log_step "Creating assets template..."
cat > "$OUTPUT_DIR/assets.md" << 'EOF'
# Assets

## Logos

| Name | Path | Notes |
|------|------|-------|
| (none extracted) | | |

## Icons

| Name | Path | Notes |
|------|------|-------|
| (none extracted) | | |

**Note:** Use Figma Export feature to download assets, then add them to source/ directory.
EOF

# Create INDEX.md
log_step "Creating INDEX.md..."
TIMESTAMP=$(date '+%Y-%m-%d %H:%M')
cat > "$OUTPUT_DIR/INDEX.md" << EOF
# $BRAND_NAME Design System (v$VERSION)

Extracted from Figma on $TIMESTAMP.

## Quick Reference

| File | Contents | Status |
|------|----------|--------|
| [colors.md](colors.md) | Color palette ($EMBEDDED_COLOR_COUNT colors) | Extracted |
| [typography.md](typography.md) | Text styles ($EMBEDDED_FONT_COUNT fonts) | Extracted |
| [spacing.md](spacing.md) | Spacing scale | Template |
| [effects.md](effects.md) | Shadows, borders | Template |
| [assets.md](assets.md) | Logos, icons | Not extracted |
| [tailwind-config.md](tailwind-config.md) | Tailwind theme | Template |

## Source

- **Figma File:** $FILE_NAME
- **File Key:** $FILE_KEY
- **Extracted:** $TIMESTAMP

## Extraction Summary

| Type | Published Styles | Embedded Data |
|------|------------------|---------------|
| Colors | $COLOR_COUNT | $EMBEDDED_COLOR_COUNT unique |
| Typography | $TEXT_COUNT | $EMBEDDED_FONT_COUNT fonts |
| Effects | $EFFECT_COUNT | - |

## Next Steps

1. Review extracted colors in \`colors.md\` and assign names
2. Review fonts in \`typography.md\` and define text styles
3. For complete text style details, export typography page from Figma as PDF
4. Update \`tailwind-config.md\` with named tokens
5. Run \`./tools/designsystem-validate $OUTPUT_DIR\` to check completeness

## Hybrid Workflow Tip

The Figma API extracts published styles + document-embedded colors/fonts.
For full design specs (sizes, weights, spacing), export documentation pages
from Figma as PDFs and ask Claude to read them.
EOF

# Create GAPS.md
log_step "Creating GAPS.md..."
cat > "$OUTPUT_DIR/GAPS.md" << 'EOF'
# Gaps

## Critical Gaps

- [ ] Color values need manual mapping from RGBA to hex
- [ ] Typography values need manual extraction
- [ ] Spacing scale needs inference from components

## Medium Gaps

- [ ] Effect styles need manual mapping
- [ ] Assets not automatically exported

## Low Gaps

- [ ] Component-level styles not extracted

---

## Resolution Instructions

See [GAP-RESOLUTION.md](GAP-RESOLUTION.md) for how to resolve gaps.
EOF

# Create GAP-RESOLUTION.md
cat > "$OUTPUT_DIR/GAP-RESOLUTION.md" << 'EOF'
# Gap Resolution Guide

## Recommended: PDF Export Workflow

The Figma API only returns "published" library styles, which may be sparse.
For comprehensive extraction, export design documentation pages as PDFs:

### Step 1: Export from Figma

1. Open the Figma file in your browser
2. Navigate to the Colors/Typography/Effects documentation pages
3. Select the frame(s) containing the design specs
4. File > Export frames to PDF
5. Save to this directory's `source/` folder

### Step 2: Let Claude Read the PDFs

Ask Claude Code to read and transcribe:

```
Read the PDFs in source/ and update colors.md with the color values you find.
Include hex codes, token names, and any usage guidelines shown.
```

Claude can read PDFs natively and extract the visual color swatches, typography
specs, and other design values that aren't available via the API.

---

## Alternative: Manual API Extraction

If you have published styles in Figma, you can extract from the JSON:

### Resolving Color Gaps

1. Open `source/figma-styles.json`
2. Find style entries with `"styleType": "FILL"`
3. Look for the `color` object with `r`, `g`, `b`, `a` values (0-1 range)
4. Convert to hex: `#RRGGBB` where each component = value * 255

**Example:**
```json
{ "r": 0.2, "g": 0.4, "b": 0.8 }
```
Converts to: `#3366CC`

### Resolving Typography Gaps

1. Open `source/figma-styles.json`
2. Find style entries with `"styleType": "TEXT"`
3. Extract font family, size, weight, line height

---

## Exporting Assets

1. Open Figma file in browser
2. Select assets to export (logos, icons, illustrations)
3. Right-click > Export
4. Choose format (SVG for icons, PNG for images)
5. Save to `source/` directory
6. Update `assets.md` with paths
EOF

# Create tailwind-config.md
log_step "Creating Tailwind config template..."
cat > "$OUTPUT_DIR/tailwind-config.md" << 'EOF'
# Tailwind Configuration

## Theme Extension

```typescript
// tailwind.config.ts
import type { Config } from 'tailwindcss'

const config: Config = {
  theme: {
    extend: {
      colors: {
        // Add colors from colors.md
        // primary: '#??????',
        // secondary: '#??????',
      },
      fontFamily: {
        // Add fonts from typography.md
        // sans: ['Font Name', 'sans-serif'],
      },
      fontSize: {
        // Add text sizes from typography.md
        // 'heading-1': ['32px', { lineHeight: '1.2', fontWeight: '700' }],
      },
      spacing: {
        // Add spacing from spacing.md
        // '18': '4.5rem',
      },
      boxShadow: {
        // Add shadows from effects.md
        // 'card': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
}

export default config
```

**Note:** Update this config with actual values from the extracted data.
EOF

# Clean up
rm -rf "$TEMP_DIR"

    echo ""
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}  Extraction Complete${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "Created: $OUTPUT_DIR/"
    echo ""
    echo "Files:"
    ls -la "$OUTPUT_DIR/" | grep -v "^d" | grep -v "^total" | awk '{print "  " $NF}'
    echo ""
    echo "Next steps:"
    echo "  1. Review source/figma-styles.json for raw data"
    echo "  2. Map values to colors.md, typography.md, etc."
    echo "  3. Update tailwind-config.md"
    echo "  4. Validate: ./tools/designsystem-validate $OUTPUT_DIR"
    echo ""

    trap - EXIT  # Clear trap
    log_end "$RUN_ID" "success" "0" "0" "Created $SYSTEM_NAME" 2>/dev/null || true
}

main
