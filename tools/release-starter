#!/bin/bash
# release-starter - Cut a release of the-agency-starter
#
# Usage:
#   ./tools/release-starter [version]
#   ./tools/release-starter 1.0.0          # Specific version
#   ./tools/release-starter patch          # Auto-increment patch (0.1.0 -> 0.1.1)
#   ./tools/release-starter minor          # Auto-increment minor (0.1.0 -> 0.2.0)
#   ./tools/release-starter major          # Auto-increment major (0.1.0 -> 1.0.0)
#   ./tools/release-starter --dry-run      # Show what would happen
#
# This tool:
# 1. Syncs files from the-agency to the-agency-starter
# 2. Cleans up cruft (logs, data, .DS_Store)
# 3. Runs verification checks
# 4. Commits and tags the release
# 5. Updates history/releases.md

set -e

# Tool version
TOOL_VERSION="1.0.0-20260110-000001"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
# Starter is now a sibling repo, not a subdirectory
STARTER_DIR="$(cd "$PROJECT_ROOT/../the-agency-starter" 2>/dev/null && pwd)"
if [[ -z "$STARTER_DIR" || ! -d "$STARTER_DIR" ]]; then
    # Fallback to environment variable or error
    STARTER_DIR="${THE_AGENCY_STARTER_DIR:-}"
fi
VERSION_FILE="$STARTER_DIR/VERSION"

# Parse arguments
DRY_RUN=false
VERSION_ARG=""

for arg in "$@"; do
    case $arg in
        --dry-run|-n)
            DRY_RUN=true
            ;;
        --version|-v)
            echo "release-starter $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            echo "release-starter - Cut a release of the-agency-starter"
            echo ""
            echo "Usage:"
            echo "  ./tools/release-starter [version]"
            echo "  ./tools/release-starter 1.0.0          # Specific version"
            echo "  ./tools/release-starter patch          # Auto-increment patch"
            echo "  ./tools/release-starter minor          # Auto-increment minor"
            echo "  ./tools/release-starter major          # Auto-increment major"
            echo "  ./tools/release-starter --dry-run      # Show what would happen"
            echo ""
            echo "Options:"
            echo "  --dry-run, -n  Show what would happen without making changes"
            echo "  --version, -v  Show tool version"
            echo "  --help, -h     Show this help"
            exit 0
            ;;
        *)
            VERSION_ARG="$arg"
            ;;
    esac
done

# Get current version
get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "0.0.0"
    fi
}

# Bump version based on type
bump_version() {
    local current="$1"
    local type="$2"

    IFS='.' read -r major minor patch <<< "$current"

    case "$type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "${major}.$((minor + 1)).0"
            ;;
        patch)
            echo "${major}.${minor}.$((patch + 1))"
            ;;
        *)
            echo "$type"  # Assume it's a specific version
            ;;
    esac
}

# Sync files from the-agency to starter
sync_files() {
    log_step "Syncing files to the-agency-starter..."

    # Files/directories to sync
    local sync_items=(
        "CLAUDE.md"
        "CONTRIBUTING.md"
        "LICENSE"
        "README.md"
        "claude/agents"
        "claude/config"
        "claude/docs"
        "claude/integrations"
        "claude/knowledge"
        "claude/principals"
        "claude/proposals"
        "claude/templates"
        "claude/workstreams"
        "tools"
        "source/apps/agency-bench"
        "source/services/agency-service"
    )

    # Create necessary directories
    mkdir -p "$STARTER_DIR/claude"
    mkdir -p "$STARTER_DIR/claude/data"
    mkdir -p "$STARTER_DIR/claude/logs"
    mkdir -p "$STARTER_DIR/source/apps"
    mkdir -p "$STARTER_DIR/source/services"

    # Sync each item
    for item in "${sync_items[@]}"; do
        local src="$PROJECT_ROOT/$item"
        local dest="$STARTER_DIR/$item"

        if [[ -e "$src" ]]; then
            # Create parent directory if needed
            mkdir -p "$(dirname "$dest")"

            if [[ -d "$src" ]]; then
                rsync -a --delete "$src/" "$dest/"
            else
                cp "$src" "$dest"
            fi
            echo "  Synced: $item"
        else
            log_warn "Missing: $item"
        fi
    done

    # Create .gitkeep files for empty directories
    touch "$STARTER_DIR/claude/data/.gitkeep"
    touch "$STARTER_DIR/claude/logs/.gitkeep"
}

# Clean up cruft
clean_cruft() {
    log_step "Cleaning up cruft..."

    # Remove patterns
    find "$STARTER_DIR" -name ".DS_Store" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.log" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db-wal" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db-shm" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "node_modules" -type d -exec rm -rf {} + 2>/dev/null || true
    find "$STARTER_DIR" -name ".claude" -type d -exec rm -rf {} + 2>/dev/null || true

    # Remove specific files that shouldn't be in starter
    rm -f "$STARTER_DIR/history/push-log.md" 2>/dev/null || true
    rm -f "$STARTER_DIR/history/releases.md" 2>/dev/null || true

    # Clean build artifacts from apps (but keep source)
    rm -rf "$STARTER_DIR/source/apps/agency-bench/src-tauri/target" 2>/dev/null || true
    rm -rf "$STARTER_DIR/source/apps/agency-bench/.next" 2>/dev/null || true
    rm -rf "$STARTER_DIR/source/apps/agency-bench/out" 2>/dev/null || true

    # Clean build artifacts from services (but keep source)
    rm -rf "$STARTER_DIR/source/services/agency-service/node_modules" 2>/dev/null || true

    echo "  Cleaned cruft"
}

# Verify the build
verify_build() {
    log_step "Verifying build..."

    local errors=0

    # Required files
    local required_files=(
        "CLAUDE.md"
        "README.md"
        "tools/myclaude"
        "tools/welcomeback"
        "tools/create-agent"
        "tools/create-workstream"
        "claude/config/agency.yaml"
        "claude/agents/housekeeping/agent.md"
        "source/apps/agency-bench/package.json"
        "source/apps/agency-bench/src-tauri/tauri.conf.json"
        "source/services/agency-service/package.json"
        "source/services/agency-service/src/index.ts"
    )

    for file in "${required_files[@]}"; do
        if [[ ! -f "$STARTER_DIR/$file" ]]; then
            log_error "Missing required file: $file"
            ((errors++))
        else
            echo "  ✓ $file"
        fi
    done

    # Check tools are executable
    for tool in "$STARTER_DIR/tools/"*; do
        if [[ -f "$tool" && ! -x "$tool" ]]; then
            log_warn "Tool not executable: $(basename "$tool")"
            chmod +x "$tool"
            echo "  Fixed: $(basename "$tool")"
        fi
    done

    # Check for secrets (basic check)
    if grep -r "ANTHROPIC_API_KEY\|sk-ant-\|password\s*=" "$STARTER_DIR" --include="*.yaml" --include="*.json" --include="*.env" 2>/dev/null; then
        log_error "Potential secrets found in starter!"
        ((errors++))
    else
        echo "  ✓ No obvious secrets"
    fi

    # Check for large files (>1MB)
    local large_files
    large_files=$(find "$STARTER_DIR" -type f -size +1M 2>/dev/null)
    if [[ -n "$large_files" ]]; then
        log_warn "Large files found:"
        echo "$large_files"
    else
        echo "  ✓ No large files"
    fi

    if [[ $errors -gt 0 ]]; then
        log_error "Verification failed with $errors error(s)"
        return 1
    fi

    log_info "Verification passed"
}

# Update CHANGELOG.md in starter
update_changelog() {
    local version="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d')

    log_step "Updating CHANGELOG.md in starter..."

    local changelog="$STARTER_DIR/CHANGELOG.md"
    if [[ -f "$changelog" ]]; then
        # Prepend release entry after the header
        local temp_file
        temp_file=$(mktemp)

        cat > "$temp_file" << EOF
## [$version] - $timestamp

- Synced from the-agency
- See GitHub release for details

EOF

        # Keep first 2 lines (header), insert new entry, then rest
        {
            head -n 2 "$changelog"
            echo ""
            cat "$temp_file"
            tail -n +3 "$changelog"
        } > "${changelog}.new"

        mv "${changelog}.new" "$changelog"
        rm -f "$temp_file"

        echo "  Updated: CHANGELOG.md"
    fi
}

# Commit and tag in the starter repo
commit_and_tag() {
    local version="$1"

    log_step "Committing and tagging in starter repo..."

    cd "$STARTER_DIR"

    # Stage all changes
    git add -A

    # Commit
    git commit -m "release: the-agency-starter v$version

Synced from the-agency and prepared for release.

Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude <noreply@anthropic.com>"

    # Tag
    git tag -a "v$version" -m "the-agency-starter v$version"

    echo "  Created commit and tag: v$version"

    # Return to original directory
    cd "$PROJECT_ROOT"
}

# Main
main() {
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  release-starter - The Agency Starter Release Tool"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # Check starter directory exists
    if [[ -z "$STARTER_DIR" || ! -d "$STARTER_DIR" ]]; then
        log_error "Starter directory not found"
        echo ""
        echo "Expected at: $(cd "$PROJECT_ROOT/.." && pwd)/the-agency-starter"
        echo "Or set THE_AGENCY_STARTER_DIR environment variable"
        exit 1
    fi

    log_info "Using starter directory: $STARTER_DIR"

    # Determine version
    local current_version
    current_version=$(get_current_version)

    local new_version
    if [[ -z "$VERSION_ARG" ]]; then
        new_version=$(bump_version "$current_version" "patch")
    else
        new_version=$(bump_version "$current_version" "$VERSION_ARG")
    fi

    log_info "Current version: $current_version"
    log_info "New version: $new_version"
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warn "DRY RUN - No changes will be made"
        echo ""

        log_step "Would sync files..."
        log_step "Would clean cruft..."
        log_step "Would verify build..."
        log_step "Would update VERSION to $new_version..."
        log_step "Would update CHANGELOG.md..."
        log_step "Would commit and tag as v$new_version..."

        echo ""
        log_info "Dry run complete. Run without --dry-run to execute."
        exit 0
    fi

    # Execute release
    sync_files
    echo ""

    clean_cruft
    echo ""

    verify_build
    echo ""

    # Write version file
    log_step "Writing version file..."
    echo "$new_version" > "$VERSION_FILE"
    echo "  VERSION: $new_version"
    echo ""

    update_changelog "$new_version"
    echo ""

    commit_and_tag "$new_version"
    echo ""

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_info "Release complete: v$new_version"
    echo ""
    echo "Next steps (in starter repo):"
    echo "  cd $STARTER_DIR"
    echo "  git push origin main"
    echo "  git push origin v$new_version"
    echo ""
    echo "Or create GitHub release:"
    echo "  gh release create v$new_version --generate-notes"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

main
