#!/bin/bash
# Backup session state - captures git status, uncommitted changes, metadata
#
# Usage: Called automatically by SessionEnd hook
#
# Why this exists:
#   Enables session continuity - capture complete work state on exit
#   Allows seamless restoration when resuming work



# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "session-backup" "agency-tool" "$@" 2>/dev/null) || true
# Tool version
TOOL_VERSION="1.0.0-20260109-000001"

# Version check
if [[ "${1:-}" == "--version" || "${1:-}" == "-v" ]]; then
    echo "session-backup $TOOL_VERSION"
    exit 0
fi

AGENTNAME=$(./tools/agentname 2>/dev/null || echo 'unknown')
TIMESTAMP=$(./tools/now 2>/dev/null || date '+%Y-%m-%d %H:%M:%S %Z')
BACKUP_DIR="claude/agents/$AGENTNAME/backups/latest"
ARCHIVE_DIR="claude/agents/$AGENTNAME/backups/archive/session-$(date +%s)"

# Ensure backup directories exist
mkdir -p "$BACKUP_DIR"
mkdir -p "$ARCHIVE_DIR"

# 1. Capture git status
git status > "$BACKUP_DIR/status.txt" 2>/dev/null

# 2. Capture current branch
git branch --show-current > "$BACKUP_DIR/current-branch.txt" 2>/dev/null

# 3. Capture uncommitted changes (if any)
if ! git diff --quiet 2>/dev/null; then
  git diff > "$BACKUP_DIR/uncommitted.patch" 2>/dev/null
fi

# 4. Capture staged changes (if any)
if ! git diff --cached --quiet 2>/dev/null; then
  git diff --cached > "$BACKUP_DIR/staged.patch" 2>/dev/null
fi

# 5. Capture session metadata
WORKSTREAM=$(./tools/workstream 2>/dev/null || echo 'unknown')
cat > "$BACKUP_DIR/session-info.json" <<EOF
{
  "agentname": "$AGENTNAME",
  "workstream": "$WORKSTREAM",
  "timestamp": "$TIMESTAMP",
  "branch": "$(git branch --show-current 2>/dev/null || echo 'unknown')",
  "last_commit": "$(git log -1 --format='%h - %s' 2>/dev/null || echo 'none')",
  "has_uncommitted": $([ -f "$BACKUP_DIR/uncommitted.patch" ] && echo 'true' || echo 'false'),
  "has_staged": $([ -f "$BACKUP_DIR/staged.patch" ] && echo 'true' || echo 'false')
}
EOF

# 6. Archive context if exists
CONTEXT_FILE="claude/agents/$AGENTNAME/backups/latest/context.jsonl"
if [[ -f "$CONTEXT_FILE" ]]; then
  cp "$CONTEXT_FILE" "$ARCHIVE_DIR/context.jsonl" 2>/dev/null
fi

# 7. Archive this backup
cp -r "$BACKUP_DIR/"* "$ARCHIVE_DIR/" 2>/dev/null

# Silent success (hook context)
exit 0
