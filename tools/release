#!/bin/bash
# Cut a release for The Agency
#
# Usage:
#   ./tools/release 0.6.0              # Create v0.6.0 release
#   ./tools/release 0.6.0-rc1          # Create v0.6.0-rc1 release candidate
#   ./tools/release patch              # Auto-increment patch (0.6.0 -> 0.6.1)
#   ./tools/release minor              # Auto-increment minor (0.6.0 -> 0.7.0)
#   ./tools/release major              # Auto-increment major (0.6.0 -> 1.0.0)
#
# Options:
#   --push         Push tag to remote after creating
#   --github       Create GitHub release (requires gh CLI)
#   --request ID   Mark REQUEST as complete
#   --dry-run      Show what would happen
#   --changelog    Generate changelog to stdout only
#   --verbose      Show detailed logging
#
# This tool:
#   1. Validates version format
#   2. Generates changelog from commits since last release
#   3. Creates annotated tag
#   4. Optionally creates GitHub release
#   5. Optionally marks REQUEST as complete

set -euo pipefail

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi

TOOL_VERSION="1.1.0-20260114-000003"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Defaults
PUSH=false
GITHUB=false
DRY_RUN=false
CHANGELOG_ONLY=false
REQUEST_ID=""
VERBOSE=false

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "release $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            head -28 "$0" | tail -27 | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        --push|-p)
            PUSH=true
            shift
            ;;
        --github|-g)
            GITHUB=true
            shift
            ;;
        --request|-r)
            REQUEST_ID="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --changelog)
            CHANGELOG_ONLY=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

VERSION_ARG="${1:-}"

if [ -z "$VERSION_ARG" ]; then
    log_error "Version required"
    echo "Usage: ./tools/release <version|patch|minor|major> [--verbose]"
    exit 1
fi

# Get the last release tag
get_last_release() {
    git tag -l 'v*' --sort=-v:refname | head -n 1
}

# Extract version from tag
tag_to_version() {
    local tag="$1"
    echo "${tag#v}"
}

# Bump version based on type
bump_version() {
    local current="$1"
    local type="$2"

    # Remove any suffix like -rc1
    local base_version="${current%%-*}"

    IFS='.' read -r major minor patch <<< "$base_version"

    case "$type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "${major}.$((minor + 1)).0"
            ;;
        patch)
            echo "${major}.${minor}.$((patch + 1))"
            ;;
        *)
            echo "$type"  # Assume it's a specific version
            ;;
    esac
}

# Generate changelog from commits
generate_changelog() {
    local since_tag="$1"
    local until="HEAD"

    echo "## Changes"
    echo ""

    if [ -n "$since_tag" ]; then
        local range="${since_tag}..${until}"
    else
        local range="HEAD"
    fi

    # Group by type
    local features=""
    local fixes=""
    local docs=""
    local refactor=""
    local other=""

    while IFS= read -r line; do
        # Parse commit message
        local subject="${line#* }"  # Remove hash prefix

        # Categorize by conventional commit prefix
        if [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ feat ]]; then
            features+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ fix ]]; then
            fixes+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ docs ]]; then
            docs+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ refactor ]]; then
            refactor+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^release: ]]; then
            # Skip release commits
            continue
        else
            other+="- ${subject}"$'\n'
        fi
    done < <(git log --oneline "$range" 2>/dev/null)

    if [ -n "$features" ]; then
        echo "### Features"
        echo "$features"
    fi

    if [ -n "$fixes" ]; then
        echo "### Bug Fixes"
        echo "$fixes"
    fi

    if [ -n "$refactor" ]; then
        echo "### Refactoring"
        echo "$refactor"
    fi

    if [ -n "$docs" ]; then
        echo "### Documentation"
        echo "$docs"
    fi

    if [ -n "$other" ]; then
        echo "### Other"
        echo "$other"
    fi
}

# Main
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    RUN_ID=$(log_start "release" "agency-tool" "$@" 2>/dev/null) || true
    echo "release [run: ${RUN_ID:-none}]"

    # Get last release
    LAST_TAG=$(get_last_release)
    LAST_VERSION=""

    if [ -n "$LAST_TAG" ]; then
        LAST_VERSION=$(tag_to_version "$LAST_TAG")
        log_info "Last release: $LAST_TAG"
    else
        LAST_VERSION="0.0.0"
        log_warn "No previous release found"
    fi

    # Determine new version
    NEW_VERSION=$(bump_version "$LAST_VERSION" "$VERSION_ARG")
    NEW_TAG="v${NEW_VERSION}"

    log_info "New release: $NEW_TAG"
    echo ""

    # Generate changelog
    CHANGELOG=$(generate_changelog "$LAST_TAG")

    if [ "$CHANGELOG_ONLY" = true ]; then
        echo "$CHANGELOG"
        trap - EXIT
        log_end "$RUN_ID" "success" 0 0 "Changelog generated"
        exit 0
    fi

    log_info "Changelog Preview:"
    echo "---"
    echo "$CHANGELOG"
    echo "---"
    echo ""

    # Dry run
    if [ "$DRY_RUN" = true ]; then
        log_warn "[DRY RUN] Would create tag: $NEW_TAG"
        if [ "$PUSH" = true ]; then
            verbose_echo "[DRY RUN] Would push tag to remote"
        fi
        if [ "$GITHUB" = true ]; then
            verbose_echo "[DRY RUN] Would create GitHub release"
        fi
        if [ -n "$REQUEST_ID" ]; then
            verbose_echo "[DRY RUN] Would mark $REQUEST_ID as complete"
        fi
        trap - EXIT
        log_end "$RUN_ID" "success" 0 0 "Dry run complete"
        exit 0
    fi

    # Check if tag already exists
    if git tag -l "$NEW_TAG" | grep -q "$NEW_TAG"; then
        log_error "Tag $NEW_TAG already exists"
        echo "Use a different version or delete the existing tag"
        trap - EXIT
        log_end "$RUN_ID" "failure" 1 0 "Tag already exists"
        exit 1
    fi

    # Check for uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
        log_warn "You have uncommitted changes"
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            trap - EXIT
            log_end "$RUN_ID" "failure" 0 0 "User aborted"
            exit 1
        fi
    fi

    # Create the tag
    RELEASE_MSG="Release ${NEW_TAG}"$'\n\n'"${CHANGELOG}"

    git tag -a "$NEW_TAG" -m "$RELEASE_MSG"
    echo "Created tag: $NEW_TAG"

    # Update history/releases.md
    REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
    RELEASES_FILE="$REPO_ROOT/history/releases.md"
    if [ -f "$RELEASES_FILE" ]; then
        RELEASE_DATE=$(date +%Y-%m-%d)
        # Prepend new release to the file (after header)
        {
            head -8 "$RELEASES_FILE"
            echo "| $NEW_TAG | $RELEASE_DATE | |"
            tail -n +9 "$RELEASES_FILE"
        } > "${RELEASES_FILE}.tmp" && mv "${RELEASES_FILE}.tmp" "$RELEASES_FILE"
        log_info "Updated history/releases.md"
    fi

    # Push if requested
    if [ "$PUSH" = true ]; then
        git push origin "$NEW_TAG"
        log_info "Pushed tag to remote"
    fi

    # Create GitHub release if requested
    if [ "$GITHUB" = true ]; then
        if ! command -v gh &> /dev/null; then
            log_warn "gh CLI not found, skipping GitHub release"
        else
            # Get GitHub token from secret-service if not already set
            if [ -z "${GH_TOKEN:-}" ]; then
                SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
                if [ -x "$SCRIPT_DIR/secret" ]; then
                    EXTRACTED_TOKEN=$("$SCRIPT_DIR/secret" get github-admin-token 2>/dev/null || true)
                    if [ -n "$EXTRACTED_TOKEN" ]; then
                        export GH_TOKEN="$EXTRACTED_TOKEN"
                        log_info "Using GitHub token from secret-service"
                    fi
                fi
            fi

            # Create release
            gh release create "$NEW_TAG" \
                --title "$NEW_TAG" \
                --notes "$CHANGELOG"

            log_info "Created GitHub release"
        fi
    fi

    # Mark REQUEST as complete if specified
    if [ -n "$REQUEST_ID" ]; then
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [ -x "$SCRIPT_DIR/tag" ]; then
            "$SCRIPT_DIR/tag" "$REQUEST_ID" complete
            log_info "Marked $REQUEST_ID as complete"
        else
            log_warn "Could not find tools/tag to mark REQUEST complete"
        fi
    fi

    echo ""
    echo "Release $NEW_TAG complete!"

    if [ "$PUSH" = false ]; then
        echo ""
        log_warn "Don't forget to push:"
        echo "  git push origin $NEW_TAG"
    fi

    trap - EXIT
    log_end "$RUN_ID" "success" 0 0 "Release $NEW_TAG complete"
}

main
