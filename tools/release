#!/bin/bash
# Cut a release for The Agency
#
# Usage:
#   ./tools/release 0.6.0              # Create v0.6.0 release
#   ./tools/release 0.6.0-rc1          # Create v0.6.0-rc1 release candidate
#   ./tools/release patch              # Auto-increment patch (0.6.0 -> 0.6.1)
#   ./tools/release minor              # Auto-increment minor (0.6.0 -> 0.7.0)
#   ./tools/release major              # Auto-increment major (0.6.0 -> 1.0.0)
#
# Options:
#   --push         Push tag to remote after creating
#   --github       Create GitHub release (requires gh CLI)
#   --request ID   Mark REQUEST as complete
#   --dry-run      Show what would happen
#   --changelog    Generate changelog to stdout only
#
# This tool:
#   1. Validates version format
#   2. Generates changelog from commits since last release
#   3. Creates annotated tag
#   4. Optionally creates GitHub release
#   5. Optionally marks REQUEST as complete

set -e

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "release" "agency-tool" "$@" 2>/dev/null) || true

TOOL_VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Defaults
PUSH=false
GITHUB=false
DRY_RUN=false
CHANGELOG_ONLY=false
REQUEST_ID=""

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "release $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            head -26 "$0" | tail -25 | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        --push|-p)
            PUSH=true
            shift
            ;;
        --github|-g)
            GITHUB=true
            shift
            ;;
        --request|-r)
            REQUEST_ID="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --changelog)
            CHANGELOG_ONLY=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

VERSION_ARG="${1:-}"

if [ -z "$VERSION_ARG" ]; then
    echo -e "${RED}Error: Version required${NC}"
    echo "Usage: ./tools/release <version|patch|minor|major>"
    exit 1
fi

# Get the last release tag
get_last_release() {
    git tag -l 'v*' --sort=-v:refname | head -n 1
}

# Extract version from tag
tag_to_version() {
    local tag="$1"
    echo "${tag#v}"
}

# Bump version based on type
bump_version() {
    local current="$1"
    local type="$2"

    # Remove any suffix like -rc1
    local base_version="${current%%-*}"

    IFS='.' read -r major minor patch <<< "$base_version"

    case "$type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "${major}.$((minor + 1)).0"
            ;;
        patch)
            echo "${major}.${minor}.$((patch + 1))"
            ;;
        *)
            echo "$type"  # Assume it's a specific version
            ;;
    esac
}

# Generate changelog from commits
generate_changelog() {
    local since_tag="$1"
    local until="HEAD"

    echo "## Changes"
    echo ""

    if [ -n "$since_tag" ]; then
        local range="${since_tag}..${until}"
    else
        local range="HEAD"
    fi

    # Group by type
    local features=""
    local fixes=""
    local docs=""
    local refactor=""
    local other=""

    while IFS= read -r line; do
        # Parse commit message
        local subject="${line#* }"  # Remove hash prefix

        # Categorize by conventional commit prefix
        if [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ feat ]]; then
            features+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ fix ]]; then
            fixes+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ docs ]]; then
            docs+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^[a-z-]+/[a-z-]+:\ refactor ]]; then
            refactor+="- ${subject#*: }"$'\n'
        elif [[ "$subject" =~ ^release: ]]; then
            # Skip release commits
            continue
        else
            other+="- ${subject}"$'\n'
        fi
    done < <(git log --oneline "$range" 2>/dev/null)

    if [ -n "$features" ]; then
        echo "### Features"
        echo "$features"
    fi

    if [ -n "$fixes" ]; then
        echo "### Bug Fixes"
        echo "$fixes"
    fi

    if [ -n "$refactor" ]; then
        echo "### Refactoring"
        echo "$refactor"
    fi

    if [ -n "$docs" ]; then
        echo "### Documentation"
        echo "$docs"
    fi

    if [ -n "$other" ]; then
        echo "### Other"
        echo "$other"
    fi
}

# Main
main() {
    # Get last release
    LAST_TAG=$(get_last_release)
    LAST_VERSION=""

    if [ -n "$LAST_TAG" ]; then
        LAST_VERSION=$(tag_to_version "$LAST_TAG")
        echo -e "${BLUE}Last release:${NC} $LAST_TAG"
    else
        LAST_VERSION="0.0.0"
        echo -e "${YELLOW}No previous release found${NC}"
    fi

    # Determine new version
    NEW_VERSION=$(bump_version "$LAST_VERSION" "$VERSION_ARG")
    NEW_TAG="v${NEW_VERSION}"

    echo -e "${BLUE}New release:${NC} $NEW_TAG"
    echo ""

    # Generate changelog
    CHANGELOG=$(generate_changelog "$LAST_TAG")

    if [ "$CHANGELOG_ONLY" = true ]; then
        echo "$CHANGELOG"
        exit 0
    fi

    echo -e "${BLUE}Changelog Preview:${NC}"
    echo "---"
    echo "$CHANGELOG"
    echo "---"
    echo ""

    # Dry run
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}[DRY RUN] Would create tag: $NEW_TAG${NC}"
        if [ "$PUSH" = true ]; then
            echo -e "${YELLOW}[DRY RUN] Would push tag to remote${NC}"
        fi
        if [ "$GITHUB" = true ]; then
            echo -e "${YELLOW}[DRY RUN] Would create GitHub release${NC}"
        fi
        if [ -n "$REQUEST_ID" ]; then
            echo -e "${YELLOW}[DRY RUN] Would mark $REQUEST_ID as complete${NC}"
        fi
        exit 0
    fi

    # Check if tag already exists
    if git tag -l "$NEW_TAG" | grep -q "$NEW_TAG"; then
        echo -e "${RED}Error: Tag $NEW_TAG already exists${NC}"
        echo "Use a different version or delete the existing tag"
        exit 1
    fi

    # Check for uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
        echo -e "${YELLOW}Warning: You have uncommitted changes${NC}"
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 1
        fi
    fi

    # Create the tag
    RELEASE_MSG="Release ${NEW_TAG}"$'\n\n'"${CHANGELOG}"

    git tag -a "$NEW_TAG" -m "$RELEASE_MSG"
    echo -e "${GREEN}Created tag: $NEW_TAG${NC}"

    # Push if requested
    if [ "$PUSH" = true ]; then
        git push origin "$NEW_TAG"
        echo -e "${GREEN}Pushed tag to remote${NC}"
    fi

    # Create GitHub release if requested
    if [ "$GITHUB" = true ]; then
        if ! command -v gh &> /dev/null; then
            echo -e "${YELLOW}Warning: gh CLI not found, skipping GitHub release${NC}"
        else
            # Read GH_TOKEN from settings if available
            SETTINGS_FILE="${HOME}/.claude/settings.local.json"
            if [ -f "$SETTINGS_FILE" ] && [ -z "$GH_TOKEN" ]; then
                EXTRACTED_TOKEN=$(grep -o 'GH_TOKEN=[^"]*' "$SETTINGS_FILE" 2>/dev/null | head -1 | cut -d'=' -f2)
                if [ -n "$EXTRACTED_TOKEN" ]; then
                    export GH_TOKEN="$EXTRACTED_TOKEN"
                fi
            fi

            # Create release
            gh release create "$NEW_TAG" \
                --title "$NEW_TAG" \
                --notes "$CHANGELOG"

            echo -e "${GREEN}Created GitHub release${NC}"
        fi
    fi

    # Mark REQUEST as complete if specified
    if [ -n "$REQUEST_ID" ]; then
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [ -x "$SCRIPT_DIR/tag" ]; then
            "$SCRIPT_DIR/tag" "$REQUEST_ID" complete
            echo -e "${GREEN}Marked $REQUEST_ID as complete${NC}"
        else
            echo -e "${YELLOW}Could not find tools/tag to mark REQUEST complete${NC}"
        fi
    fi

    echo ""
    echo -e "${GREEN}Release $NEW_TAG complete!${NC}"

    if [ "$PUSH" = false ]; then
        echo ""
        echo -e "${YELLOW}Don't forget to push:${NC}"
        echo "  git push origin $NEW_TAG"
    fi
}

main
