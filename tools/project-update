#!/bin/bash
#
# project-update - Update an existing project with latest starter changes
#
# Usage:
#   project-update --preview              # Preview changes without applying
#   project-update --apply                # Apply updates
#   project-update --status               # Show current version status
#   project-update --init                 # Initialize tracking for existing project
#   project-update --check                # Check for updates (read-only)
#   project-update --check --json         # Check with machine-readable output
#   project-update --from=/path/to/starter --apply  # Use local starter
#
# Protected paths (never touched):
#   tools/local/               Project-specific tools
#   claude/agents/local/       Local agent customizations
#   claude/knowledge/local/    Project-specific knowledge
#   claude/docs/local/         Project-specific docs
#   claude/principals/         User's principals and requests
#   .agency/                   Local metadata

set -e

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "project-update" "agency-tool" "$@" 2>/dev/null) || true

# Tool version
TOOL_VERSION="1.1.0-20260114-000001"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
DIM='\033[2m'
NC='\033[0m'

# Defaults
VERBOSE=false
JSON_OUTPUT=false

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Get project root (where we're running from)
PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
AGENCY_DIR="$PROJECT_ROOT/.agency"
MANIFEST_FILE="$AGENCY_DIR/manifest.json"

# Default source (GitHub)
STARTER_SOURCE=""
GITHUB_URL="https://github.com/the-agency-ai/the-agency-starter"

# Protected paths that are NEVER updated
PROTECTED_PATHS=(
    "tools/local/"
    "claude/agents/local/"
    "claude/knowledge/local/"
    "claude/docs/local/"
    "claude/principals/"
    "claude/workstreams/*/sprints/"
    "claude/agents/*/WORKLOG.md"
    "claude/agents/*/ADHOC-WORKLOG.md"
    ".agency/"
    ".git/"
)

# Parse arguments
MODE=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "project-update $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            echo "project-update - Update project from The Agency Starter"
            echo ""
            echo "Usage:"
            echo "  project-update --status           Show current version status"
            echo "  project-update --preview          Preview changes without applying"
            echo "  project-update --apply            Apply updates"
            echo "  project-update --init             Initialize tracking for existing project"
            echo "  project-update --check            Check for updates (read-only)"
            echo "  project-update --check --json     Check with machine-readable output"
            echo ""
            echo "Options:"
            echo "  --from=PATH     Use local starter directory instead of GitHub"
            echo "  --json          Output in JSON format (use with --check)"
            echo "  --verbose       Show detailed logging"
            echo "  -v, --version   Show tool version"
            echo "  -h, --help      Show this help"
            echo ""
            echo "Protected paths (never touched):"
            echo "  tools/local/             Project-specific tools"
            echo "  claude/principals/       User's principals and requests"
            echo "  claude/agents/*/WORKLOG.md  Agent work history"
            echo "  .agency/                 Local metadata"
            exit 0
            ;;
        --preview)
            MODE="preview"
            shift
            ;;
        --apply)
            MODE="apply"
            shift
            ;;
        --status)
            MODE="status"
            shift
            ;;
        --init)
            MODE="init"
            shift
            ;;
        --check)
            MODE="check"
            shift
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --from=*)
            STARTER_SOURCE="${1#*=}"
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Require a mode
if [[ -z "$MODE" ]]; then
    log_error "No mode specified"
    echo ""
    echo "Usage:"
    echo "  project-update --preview    Preview changes"
    echo "  project-update --apply      Apply updates"
    echo "  project-update --status     Show version status"
    echo "  project-update --init       Initialize tracking"
    echo "  project-update --check      Check for updates (read-only)"
    echo "  --verbose                   Show detailed logging"
    exit 1
fi

# Validate --json flag is only used with --check
if [[ "$JSON_OUTPUT" == "true" ]] && [[ "$MODE" != "check" ]]; then
    log_error "--json flag is only valid with --check mode"
    exit 1
fi

# Helper: Calculate SHA256 hash of a file
file_hash() {
    local file="$1"
    if [[ -f "$file" ]]; then
        shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1
    else
        echo ""
    fi
}

# Helper: Check if path is protected
is_protected() {
    local path="$1"
    for pattern in "${PROTECTED_PATHS[@]}"; do
        # Handle glob patterns
        if [[ "$path" == $pattern* ]] || [[ "$path" == */$pattern* ]]; then
            return 0
        fi
        # Handle wildcard patterns like */WORKLOG.md
        if [[ "$pattern" == *"*"* ]]; then
            local regex_pattern="${pattern//\*/.*}"
            if [[ "$path" =~ $regex_pattern ]]; then
                return 0
            fi
        fi
    done
    return 1
}

# Helper: Get current project version
get_project_version() {
    if [[ -f "$MANIFEST_FILE" ]]; then
        # Use Python for reliable JSON parsing (available on macOS and most Linux)
        python3 -c "import json,sys; print(json.load(open(sys.argv[1])).get('project',{}).get('starter_version','unknown'))" "$MANIFEST_FILE" 2>/dev/null || echo "unknown"
    else
        echo "untracked"
    fi
}

# Helper: Get starter version from source
get_starter_version() {
    local source="$1"
    if [[ -f "$source/VERSION" ]]; then
        cat "$source/VERSION" | tr -d '[:space:]'
    else
        echo "unknown"
    fi
}

# Helper: Create backup of a file
backup_file() {
    local file="$1"
    local backup_name="${file}.backup-$(date +%Y%m%d-%H%M%S)"
    cp "$file" "$backup_name"
    echo "$backup_name"
}

# Helper: Merge CLAUDE.md preserving PROJECT section
merge_claude_md() {
    local source_file="$1"
    local target_file="$2"

    # If target doesn't have markers, just use source
    if ! grep -q "<!-- PROJECT:START" "$target_file" 2>/dev/null; then
        cp "$source_file" "$target_file"
        return 0
    fi

    # Extract project section from target
    local project_section=$(sed -n '/<!-- PROJECT:START/,/<!-- PROJECT:END/p' "$target_file")

    # If source has markers, do a proper merge
    if grep -q "<!-- AGENCY:END" "$source_file" 2>/dev/null; then
        # Get everything up to and including AGENCY:END from source
        local agency_section=$(sed -n '1,/<!-- AGENCY:END/p' "$source_file")

        # Combine: agency section + project section
        echo "$agency_section" > "$target_file"
        echo "" >> "$target_file"
        echo "$project_section" >> "$target_file"
    else
        # Source doesn't have markers, wrap it and preserve project section
        {
            echo "<!-- AGENCY:START - Do not edit this section -->"
            cat "$source_file"
            echo "<!-- AGENCY:END -->"
            echo ""
            echo "$project_section"
        } > "$target_file"
    fi
}

# Status mode: Show current version
status_mode() {
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  Project Update Status${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    local project_version=$(get_project_version)

    echo -e "  Project:    ${GREEN}$(basename "$PROJECT_ROOT")${NC}"
    echo -e "  Location:   $PROJECT_ROOT"
    echo -e "  Version:    ${GREEN}$project_version${NC}"

    if [[ -f "$MANIFEST_FILE" ]]; then
        local installed_at=$(python3 -c "import json,sys; print(json.load(open(sys.argv[1])).get('project',{}).get('created_at', 'unknown'))" "$MANIFEST_FILE" 2>/dev/null)
        local source_type=$(python3 -c "import json,sys; print(json.load(open(sys.argv[1])).get('source',{}).get('type', 'unknown'))" "$MANIFEST_FILE" 2>/dev/null)

        echo -e "  Installed:  $installed_at"
        echo -e "  Source:     $source_type"
    else
        echo ""
        echo -e "  ${YELLOW}Version tracking not initialized.${NC}"
        echo -e "  Run: ${BLUE}./tools/project-update --init${NC}"
    fi

    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Init mode: Initialize manifest for existing project
init_mode() {
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  Initializing Project Manifest${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    # Check if already initialized
    if [[ -f "$MANIFEST_FILE" ]]; then
        echo -e "${YELLOW}Manifest already exists.${NC}"
        echo ""
        echo -e "Current version: ${GREEN}$(get_project_version)${NC}"
        echo ""
        echo "To re-initialize, remove $MANIFEST_FILE and run again."
        exit 0
    fi

    # Require --from for init mode (need starter to read registry.json)
    if [[ -z "$STARTER_SOURCE" ]]; then
        echo -e "${YELLOW}Warning: No starter source specified.${NC}"
        echo "For full manifest with components, use: --init --from=/path/to/starter"
        echo ""
    fi

    # Create .agency directory
    mkdir -p "$AGENCY_DIR"

    # Determine source for version
    local starter_version="unknown"
    if [[ -n "$STARTER_SOURCE" ]] && [[ -f "$STARTER_SOURCE/VERSION" ]]; then
        starter_version=$(cat "$STARTER_SOURCE/VERSION" | tr -d '[:space:]')
    elif [[ -f "$PROJECT_ROOT/VERSION" ]]; then
        starter_version=$(cat "$PROJECT_ROOT/VERSION" | tr -d '[:space:]')
    fi

    local source_type="local"
    local source_path="$STARTER_SOURCE"
    if [[ -z "$STARTER_SOURCE" ]]; then
        source_type="github"
        source_path=""
    fi

    local now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local project_name=$(basename "$PROJECT_ROOT")

    echo "Building manifest..."

    # Build components JSON from registry.json if available
    local components_json="{}"
    if [[ -n "$STARTER_SOURCE" ]] && [[ -f "$STARTER_SOURCE/registry.json" ]]; then
        echo "  Reading components from registry.json..."
        components_json=$(python3 - "$STARTER_SOURCE/registry.json" "$PROJECT_ROOT" "$now" << 'EOF'
import json
import os
import sys

registry_file = sys.argv[1]
project_root = sys.argv[2]
now = sys.argv[3]

with open(registry_file, 'r') as f:
    data = json.load(f)

components = {}

for name, info in data.get('components', {}).items():
    # Check if component files exist in the project
    files = info.get('files', [])
    exists = False
    for pattern in files:
        # Simple existence check (not full glob)
        base_path = pattern.split('*')[0].rstrip('/')
        if os.path.exists(os.path.join(project_root, base_path)):
            exists = True
            break

    if exists:
        components[name] = {
            'version': info.get('version', 'unknown'),
            'status': 'installed',
            'dependencies': 'pending' if info.get('install_hook') else 'none',
            'installed_at': now
        }

print(json.dumps(components, indent=4))
EOF
)
    fi

    # Calculate file hashes
    echo "  Calculating file hashes..."
    local files_json=$(python3 - "$PROJECT_ROOT" "$starter_version" "$STARTER_SOURCE" << 'EOF'
import json
import hashlib
import os
import sys

project_root = sys.argv[1]
starter_version = sys.argv[2]
starter_source = sys.argv[3] if len(sys.argv) > 3 and sys.argv[3] else ""

protected_patterns = [
    "tools/local/",
    "claude/agents/local/",
    "claude/knowledge/local/",
    "claude/docs/local/",
    "claude/principals/",
    "claude/workstreams/*/sprints/",
    ".agency/",
    ".git/"
]

def is_protected(path):
    for pattern in protected_patterns:
        if pattern.endswith('/'):
            if path.startswith(pattern) or ('/' + pattern) in ('/' + path):
                return True
        elif '*' in pattern:
            import fnmatch
            if fnmatch.fnmatch(path, pattern):
                return True
        elif path == pattern or path.endswith('/' + pattern):
            return True
    return False

def file_hash(filepath):
    try:
        with open(filepath, 'rb') as f:
            return hashlib.sha256(f.read()).hexdigest()
    except:
        return None

def get_starter_hash(rel_path):
    if not starter_source:
        return None
    starter_file = os.path.join(starter_source, rel_path)
    if os.path.exists(starter_file):
        return file_hash(starter_file)
    return None

files = {}
for root, dirs, filenames in os.walk(project_root):
    # Skip .git and node_modules
    dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '.next', 'target', 'dist']]

    for filename in filenames:
        filepath = os.path.join(root, filename)
        rel_path = os.path.relpath(filepath, project_root)

        # Skip protected paths
        if is_protected(rel_path):
            continue

        # Only track claude/ and tools/ directories
        if not (rel_path.startswith('claude/') or rel_path.startswith('tools/')):
            continue

        current_hash = file_hash(filepath)
        if current_hash:
            starter_hash = get_starter_hash(rel_path)
            modified = False
            if starter_hash and starter_hash != current_hash:
                modified = True

            files[rel_path] = {
                'hash': current_hash,
                'version': starter_version,
                'modified': modified
            }

print(json.dumps(files, indent=4, sort_keys=True))
EOF
)

    # Build source JSON
    local source_json=""
    if [[ "$source_type" == "local" ]]; then
        source_json="{\"type\": \"local\", \"path\": \"$source_path\"}"
    else
        source_json="{\"type\": \"github\", \"repo\": \"the-agency-ai/the-agency-starter\"}"
    fi

    # Write manifest.json
    python3 - "$MANIFEST_FILE" "$project_name" "$now" "$starter_version" "$source_json" "$components_json" "$files_json" << 'EOF'
import json
import sys

manifest_file = sys.argv[1]
project_name = sys.argv[2]
now = sys.argv[3]
starter_version = sys.argv[4]
source_json = sys.argv[5]
components_json = sys.argv[6]
files_json = sys.argv[7]

# Parse JSON strings (they contain lowercase true/false which aren't Python literals)
source_data = json.loads(source_json)
components_data = json.loads(components_json)
files_data = json.loads(files_json)

manifest = {
    "schema_version": "1.0",
    "project": {
        "name": project_name,
        "created_at": now,
        "starter_version": starter_version
    },
    "source": source_data,
    "components": components_data,
    "files": files_data
}

with open(manifest_file, 'w') as f:
    json.dump(manifest, f, indent=2)
EOF

    echo "  Manifest created: $MANIFEST_FILE"

    # Register in starter's projects.json if --from specified
    if [[ -n "$STARTER_SOURCE" ]]; then
        echo "  Registering project in starter..."
        local starter_projects_file="$STARTER_SOURCE/.agency/projects.json"
        mkdir -p "$STARTER_SOURCE/.agency"

        python3 - "$starter_projects_file" "$PROJECT_ROOT" "$project_name" "$now" "$starter_version" << 'EOF'
import json
import os
import sys

projects_file = sys.argv[1]
project_path = sys.argv[2]
project_name = sys.argv[3]
now = sys.argv[4]
starter_version = sys.argv[5]

# Create or load projects.json
if os.path.exists(projects_file):
    with open(projects_file, 'r') as f:
        data = json.load(f)
else:
    data = {"schema_version": "1.0", "projects": []}

# Check if project already registered
already_registered = any(p.get('path') == project_path for p in data.get('projects', []))

if not already_registered:
    new_project = {
        "name": project_name,
        "path": project_path,
        "created_at": now,
        "starter_version": starter_version,
        "status": "current"
    }
    data['projects'].append(new_project)

    with open(projects_file, 'w') as f:
        json.dump(data, f, indent=2)
    print("  Project registered in starter")
else:
    print("  Project already registered in starter")
EOF
    fi

    # Count files and components
    local file_count=$(python3 -c "import json,sys; print(len(json.load(open(sys.argv[1])).get('files', {})))" "$MANIFEST_FILE" 2>/dev/null || echo "0")
    local component_count=$(python3 -c "import json,sys; print(len(json.load(open(sys.argv[1])).get('components', {})))" "$MANIFEST_FILE" 2>/dev/null || echo "0")

    echo ""
    echo -e "${GREEN}Manifest initialized!${NC}"
    echo ""
    echo -e "  Project:    ${GREEN}$project_name${NC}"
    echo -e "  Version:    ${GREEN}$starter_version${NC}"
    echo -e "  Components: ${GREEN}$component_count${NC}"
    echo -e "  Files:      ${GREEN}$file_count${NC}"
    echo ""
    echo "Run ./tools/project-update --status to see details."
    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Check mode: Read-only update check with optional JSON output
check_mode() {
    # Require manifest
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        if [[ "$JSON_OUTPUT" == "true" ]]; then
            echo '{"error": "Manifest not found. Run --init first."}'
            exit 1
        else
            log_error "Manifest not found."
            echo "Run first: ./tools/project-update --init --from=/path/to/starter"
            exit 1
        fi
    fi

    # Fetch starter
    local starter_dir
    if [[ "$JSON_OUTPUT" != "true" ]]; then
        starter_dir=$(fetch_starter)
    else
        # Suppress output for JSON mode
        starter_dir=$(fetch_starter 2>/dev/null)
    fi
    local temp_cleanup=""
    if [[ -z "$STARTER_SOURCE" ]]; then
        temp_cleanup="$starter_dir"
    fi

    # Cleanup temp on exit
    cleanup() {
        if [[ -n "$temp_cleanup" ]] && [[ -d "$temp_cleanup" ]]; then
            rm -rf "$temp_cleanup"
        fi
    }
    trap cleanup EXIT

    # Get version info
    local current_version=$(python3 -c "import json,sys; print(json.load(open(sys.argv[1])).get('project', {}).get('starter_version', 'unknown'))" "$MANIFEST_FILE" 2>/dev/null || echo "unknown")
    local latest_version=$(get_starter_version "$starter_dir")

    # Check for breaking changes in CHANGELOG
    local breaking_changes=false
    if [[ -f "$starter_dir/CHANGELOG.md" ]]; then
        # Look for BREAKING CHANGE markers between current and latest version
        if grep -qi "BREAKING" "$starter_dir/CHANGELOG.md" 2>/dev/null; then
            breaking_changes=true
        fi
    fi

    # Analyze files using Python
    local result=$(python3 - "$PROJECT_ROOT" "$starter_dir" "$MANIFEST_FILE" << 'EOF'
import json
import hashlib
import os
import sys

project_root = sys.argv[1]
starter_dir = sys.argv[2]
manifest_file = sys.argv[3]

# Load manifest
with open(manifest_file, 'r') as f:
    manifest = json.load(f)

manifest_files = manifest.get('files', {})
manifest_components = manifest.get('components', {})

# Load starter registry
registry_file = os.path.join(starter_dir, 'registry.json')
starter_registry = {}
if os.path.exists(registry_file):
    with open(registry_file, 'r') as f:
        starter_registry = json.load(f)

protected_patterns = [
    "tools/local/",
    "claude/agents/local/",
    "claude/knowledge/local/",
    "claude/docs/local/",
    "claude/principals/",
    "claude/workstreams/*/sprints/",
    ".agency/",
    ".git/"
]

def is_protected(path):
    for pattern in protected_patterns:
        if pattern.endswith('/'):
            if path.startswith(pattern) or ('/' + pattern) in ('/' + path):
                return True
        elif '*' in pattern:
            import fnmatch
            if fnmatch.fnmatch(path, pattern):
                return True
        elif path == pattern or path.endswith('/' + pattern):
            return True
    return False

def file_hash(filepath):
    try:
        with open(filepath, 'rb') as f:
            return hashlib.sha256(f.read()).hexdigest()
    except:
        return None

files_to_update = []
files_modified_locally = []
components_outdated = set()

# Walk starter files
for root, dirs, filenames in os.walk(starter_dir):
    dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '.next', 'target', 'dist']]

    for filename in filenames:
        source_path = os.path.join(root, filename)
        rel_path = os.path.relpath(source_path, starter_dir)
        target_path = os.path.join(project_root, rel_path)

        # Skip hidden files except .gitignore
        if rel_path.startswith('.') and rel_path != '.gitignore':
            continue

        # Skip protected paths
        if is_protected(rel_path):
            continue

        source_hash = file_hash(source_path)
        target_hash = file_hash(target_path) if os.path.exists(target_path) else None

        if target_hash is None:
            # New file from starter
            files_to_update.append(rel_path)
        elif source_hash != target_hash:
            # File differs
            tracked_info = manifest_files.get(rel_path, {})
            tracked_hash = tracked_info.get('hash', '')

            if target_hash != tracked_hash and tracked_hash:
                # User has modified this file
                files_modified_locally.append(rel_path)

            # File needs update
            files_to_update.append(rel_path)

# Check component versions
starter_components = starter_registry.get('components', {})
for comp_name, comp_info in manifest_components.items():
    installed_version = comp_info.get('version', '')
    starter_version_val = starter_components.get(comp_name, {}).get('version', '')
    if starter_version_val and installed_version != starter_version_val:
        components_outdated.add(comp_name)

result = {
    'files_to_update': sorted(files_to_update),
    'files_modified_locally': sorted(files_modified_locally),
    'components_outdated': sorted(list(components_outdated))
}
print(json.dumps(result))
EOF
)

    # Parse Python result
    local files_to_update=$(echo "$result" | python3 -c "import json,sys; print(json.dumps(json.load(sys.stdin)['files_to_update']))")
    local files_modified_locally=$(echo "$result" | python3 -c "import json,sys; print(json.dumps(json.load(sys.stdin)['files_modified_locally']))")
    local components_outdated=$(echo "$result" | python3 -c "import json,sys; print(json.dumps(json.load(sys.stdin)['components_outdated']))")

    # Count updates
    local update_count=$(echo "$files_to_update" | python3 -c "import json,sys; print(len(json.load(sys.stdin)))")
    local modified_count=$(echo "$files_modified_locally" | python3 -c "import json,sys; print(len(json.load(sys.stdin)))")
    local outdated_count=$(echo "$components_outdated" | python3 -c "import json,sys; print(len(json.load(sys.stdin)))")

    local updates_available=false
    if [[ "$update_count" -gt 0 ]] || [[ "$current_version" != "$latest_version" ]]; then
        updates_available=true
    fi

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        # JSON output
        local updates_bool=$([[ "$updates_available" == "true" ]] && echo "true" || echo "false")
        local breaking_bool=$([[ "$breaking_changes" == "true" ]] && echo "true" || echo "false")
        python3 - "$current_version" "$latest_version" "$updates_bool" "$breaking_bool" "$files_to_update" "$files_modified_locally" "$components_outdated" << 'EOF'
import json
import sys

current_version = sys.argv[1]
latest_version = sys.argv[2]
updates_available = sys.argv[3] == "true"
breaking_changes = sys.argv[4] == "true"
files_to_update = json.loads(sys.argv[5])
files_modified_locally = json.loads(sys.argv[6])
components_outdated = json.loads(sys.argv[7])

output = {
    "current_version": current_version,
    "latest_version": latest_version,
    "updates_available": updates_available,
    "files_to_update": files_to_update,
    "files_modified_locally": files_modified_locally,
    "components_outdated": components_outdated,
    "breaking_changes": breaking_changes
}
print(json.dumps(output, indent=2))
EOF
    else
        # Human-readable output
        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}  Update Check${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "  Current version: ${GREEN}$current_version${NC}"
        echo -e "  Latest version:  ${GREEN}$latest_version${NC}"
        echo ""

        if [[ "$updates_available" == "true" ]]; then
            echo -e "  ${YELLOW}Updates available!${NC}"
            echo ""
            echo -e "  Files to update:        ${BLUE}$update_count${NC}"
            echo -e "  Locally modified files: ${YELLOW}$modified_count${NC}"
            echo -e "  Outdated components:    ${YELLOW}$outdated_count${NC}"

            if [[ "$breaking_changes" == "true" ]]; then
                echo ""
                echo -e "  ${RED}Warning: Breaking changes detected!${NC}"
                echo "  Review CHANGELOG.md before updating."
            fi

            if [[ "$modified_count" -gt 0 ]]; then
                echo ""
                echo "  Modified files (will be backed up):"
                echo "$files_modified_locally" | python3 -c "import json,sys; [print(f'    - {f}') for f in json.load(sys.stdin)[:5]]"
                if [[ "$modified_count" -gt 5 ]]; then
                    echo "    ... and $((modified_count - 5)) more"
                fi
            fi

            echo ""
            echo "  To apply updates, run:"
            echo -e "    ${BLUE}./tools/project-update --preview${NC}  # Review changes"
            echo -e "    ${BLUE}./tools/project-update --apply${NC}    # Apply changes"
        else
            echo -e "  ${GREEN}Project is up to date!${NC}"
        fi

        echo ""
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    fi
}

# Fetch starter to temp directory
fetch_starter() {
    if [[ -n "$STARTER_SOURCE" ]]; then
        # Use local source
        if [[ ! -d "$STARTER_SOURCE" ]]; then
            echo -e "${RED}Error: Starter source not found: $STARTER_SOURCE${NC}"
            exit 1
        fi
        echo "$STARTER_SOURCE"
    else
        # Clone from GitHub to temp directory
        local temp_dir=$(mktemp -d)
        echo -e "${DIM}Fetching latest starter from GitHub...${NC}" >&2
        if ! git clone --quiet --depth 1 "$GITHUB_URL" "$temp_dir" 2>/dev/null; then
            echo -e "${RED}Error: Failed to fetch starter from GitHub${NC}" >&2
            rm -rf "$temp_dir"
            exit 1
        fi
        echo "$temp_dir"
    fi
}

# Preview/Apply mode
update_mode() {
    local apply=$1

    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    if [[ "$apply" == "true" ]]; then
        echo -e "${BLUE}  Applying Updates${NC}"
    else
        echo -e "${BLUE}  Preview Updates${NC}"
    fi
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    # Check version tracking
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        echo -e "${YELLOW}Version tracking not initialized.${NC}"
        echo ""
        echo "Run first: ./tools/project-update --init"
        exit 1
    fi

    local project_version=$(get_project_version)
    echo -e "  Current version: ${GREEN}$project_version${NC}"

    # Fetch starter
    local starter_dir=$(fetch_starter)
    local temp_cleanup=""
    if [[ -z "$STARTER_SOURCE" ]]; then
        temp_cleanup="$starter_dir"
    fi

    # Cleanup temp on exit
    cleanup() {
        if [[ -n "$temp_cleanup" ]] && [[ -d "$temp_cleanup" ]]; then
            rm -rf "$temp_cleanup"
        fi
    }
    trap cleanup EXIT

    local starter_version=$(get_starter_version "$starter_dir")
    echo -e "  Starter version: ${GREEN}$starter_version${NC}"
    echo ""

    # Compare versions
    if [[ "$project_version" == "$starter_version" ]]; then
        echo -e "${GREEN}Project is up to date!${NC}"
        echo ""
        exit 0
    fi

    # Find files that need updating
    local added=0
    local updated=0
    local conflicts=0
    local skipped=0

    echo "Comparing files..."
    echo ""

    # Process files from starter
    while IFS= read -r -d '' source_file; do
        local rel_path="${source_file#$starter_dir/}"
        local target_file="$PROJECT_ROOT/$rel_path"

        # Skip hidden files and directories (except .gitignore)
        if [[ "$rel_path" == .* ]] && [[ "$rel_path" != ".gitignore" ]]; then
            continue
        fi

        # Skip protected paths
        if is_protected "$rel_path"; then
            ((skipped++))
            continue
        fi

        local source_hash=$(file_hash "$source_file")
        local target_hash=$(file_hash "$target_file")

        if [[ ! -f "$target_file" ]]; then
            # New file
            echo -e "  ${GREEN}+ $rel_path${NC} (new)"
            ((added++))

            if [[ "$apply" == "true" ]]; then
                mkdir -p "$(dirname "$target_file")"
                cp "$source_file" "$target_file"
            fi
        elif [[ "$source_hash" != "$target_hash" ]]; then
            # File differs - check if user modified it
            local tracked_hash=$(python3 -c "import json,sys; files=json.load(open(sys.argv[1])).get('files',{}); print(files.get(sys.argv[2],{}).get('hash',''))" "$MANIFEST_FILE" "$rel_path" 2>/dev/null)

            if [[ "$target_hash" == "$tracked_hash" ]] || [[ -z "$tracked_hash" ]]; then
                # File unchanged by user, safe to update
                echo -e "  ${BLUE}~ $rel_path${NC} (updated)"
                ((updated++))

                if [[ "$apply" == "true" ]]; then
                    if [[ "$rel_path" == "CLAUDE.md" ]]; then
                        merge_claude_md "$source_file" "$target_file"
                    else
                        cp "$source_file" "$target_file"
                    fi
                fi
            else
                # User has modified this file - conflict
                echo -e "  ${YELLOW}! $rel_path${NC} (conflict - user modified)"
                ((conflicts++))

                if [[ "$apply" == "true" ]]; then
                    local backup=$(backup_file "$target_file")
                    echo -e "    ${DIM}Backup: $backup${NC}"
                    cp "$source_file" "$target_file"
                fi
            fi
        fi
    done < <(find "$starter_dir" -type f -print0 2>/dev/null)

    echo ""
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo "Summary:"
    echo -e "  Added:     ${GREEN}$added${NC}"
    echo -e "  Updated:   ${BLUE}$updated${NC}"
    echo -e "  Conflicts: ${YELLOW}$conflicts${NC}"
    echo -e "  Skipped:   ${DIM}$skipped (protected)${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    if [[ "$apply" == "true" ]]; then
        # Update version tracking
        local now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        python3 -c "
import json
import sys
manifest_file = sys.argv[1]
new_version = sys.argv[2]
with open(manifest_file, 'r') as f:
    data = json.load(f)
if 'project' not in data:
    data['project'] = {}
data['project']['starter_version'] = new_version
with open(manifest_file, 'w') as f:
    json.dump(data, f, indent=2)
" "$MANIFEST_FILE" "$starter_version"
        echo ""
        echo -e "${GREEN}Update complete!${NC}"

        if [[ $conflicts -gt 0 ]]; then
            echo ""
            echo -e "${YELLOW}Note: $conflicts file(s) had conflicts and were backed up.${NC}"
            echo "Review the .backup-* files to recover any local changes."
        fi
    else
        echo ""
        echo "To apply these changes, run:"
        echo -e "  ${BLUE}./tools/project-update --apply${NC}"
    fi

    echo ""
}

# Main dispatch
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    [[ "$VERBOSE" == "true" ]] && echo "project-update [run: ${RUN_ID:-none}]"

    case "$MODE" in
        status)
            status_mode
            ;;
        init)
            init_mode
            ;;
        check)
            check_mode
            ;;
        preview)
            update_mode false
            ;;
        apply)
            update_mode true
            ;;
    esac

    trap - EXIT
    log_end "$RUN_ID" "success" 0 0 "project-update $MODE complete" 2>/dev/null || true
}

main
