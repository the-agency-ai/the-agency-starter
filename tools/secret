#!/bin/bash
# secret - CLI for the Secret Service API
#
# Manage secrets, vault, access control, and audit trails.
#
# Usage:
#   ./tools/secret <command> [options]
#
# Vault Commands:
#   vault init                Initialize vault with passphrase
#   vault unlock              Unlock vault with passphrase
#   vault lock                Lock vault
#   vault status              Check vault status
#
# Passphrase Input (for vault init/unlock):
#   --passphrase=<pass>       Provide passphrase via flag
#   VAULT_PASSPHRASE env var  Provide passphrase via environment
#   (or interactive prompt if TTY available)
#
# Secret Commands:
#   create <name>             Create a new secret
#   list                      List all secrets
#   get <name>                Fetch decrypted secret value
#   show <name>               Show secret metadata only
#   update <name>             Update secret metadata
#   rotate <name>             Rotate secret value
#   delete <name>             Delete a secret
#
# Tagging:
#   tag <name> --tool=<tool>    Add a tool tag
#   untag <name> --tool=<tool>  Remove a tool tag
#
# Access Control:
#   grant <name>              Grant access to a secret
#   revoke <name>             Revoke access from a secret
#
# Audit:
#   audit <name>              View audit log for a secret
#
# Options:
#   --type=<type>             Secret type (api_key, password, token, certificate, ssh_key, other)
#   --service=<service>       Service name (e.g., GitHub, AWS)
#   --description=<desc>      Description of the secret
#   --tool=<tool>             Tool name for tagging
#   --to=<identity>           Identity to grant access (e.g., agent:housekeeping)
#   --from=<identity>         Identity to revoke access from
#   --permission=<perm>       Permission level (read, use, manage)
#   --json                    Output in JSON format
#   -h, --help                Show this help
#   -v, --version             Show version
#
# Examples:
#   ./tools/secret vault init
#   ./tools/secret create github-token --type=api_key --service=GitHub
#   ./tools/secret list --service=GitHub
#   ./tools/secret get github-token
#   ./tools/secret tag github-token --tool=gh
#   ./tools/secret grant github-token --to=agent:housekeeping --permission=read
#   ./tools/secret audit github-token

set -euo pipefail

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "secret" "agency-tool" "$@" 2>/dev/null) || true

# Tool version
TOOL_VERSION="1.0.0-20260114-000008"

# Defaults
VERBOSE=false

# API configuration
API_BASE="${SECRET_SERVICE_URL:-http://localhost:3141/api/secret}"
AGENCY_USER="${AGENCY_USER:-principal:jordan}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Output format
JSON_OUTPUT=false

# Parse global options first
while [[ $# -gt 0 ]]; do
    case $1 in
        --version|-v)
            echo "secret $TOOL_VERSION"
            log_end "$RUN_ID" "success" 0 0 "Version check" 2>/dev/null || true
            exit 0
            ;;
        --help|-h)
            head -50 "$0" | tail -49 | sed 's/^# //' | sed 's/^#//'
            log_end "$RUN_ID" "success" 0 0 "Help displayed" 2>/dev/null || true
            exit 0
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

verbose_echo "secret [run: ${RUN_ID:-none}]"

# Helper: make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"

    log_step "API request: $method $endpoint"

    local url="${API_BASE}${endpoint}"
    local curl_args=(-s -w "\n%{http_code}" -X "$method" -H "X-Agency-User: $AGENCY_USER")

    # Add session token if available (keeps vault alive)
    if [[ -n "${VAULT_SESSION_TOKEN:-}" ]]; then
        curl_args+=(-H "X-Vault-Session-Token: $VAULT_SESSION_TOKEN")
    fi

    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local response
    response=$(curl "${curl_args[@]}" "$url" 2>/dev/null) || {
        log_error "Failed to connect to Secret Service at $url"
        echo "Is the service running? Start it with: npm run dev (in secret-service directory)" >&2
        log_end "$RUN_ID" "failure" 1 0 "Connection failed" 2>/dev/null || true
        exit 1
    }

    # Split response and status code
    local body status_code
    body=$(echo "$response" | sed '$d')
    status_code=$(echo "$response" | tail -1)

    verbose_echo "  Response status: $status_code"

    # Check for errors
    if [[ "$status_code" -ge 400 ]]; then
        local error_msg
        error_msg=$(echo "$body" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('error','Unknown error'))" 2>/dev/null || echo "$body")
        log_error "API error ($status_code): $error_msg"
        log_end "$RUN_ID" "failure" 1 0 "API error" 2>/dev/null || true
        exit 1
    fi

    echo "$body"
}

# Helper: prompt for passphrase
# Supports: interactive TTY, --passphrase flag, VAULT_PASSPHRASE env var
prompt_passphrase() {
    local prompt="${1:-Enter passphrase}"
    local passphrase

    # Check for passphrase in environment variable first
    if [[ -n "${VAULT_PASSPHRASE:-}" ]]; then
        echo "$VAULT_PASSPHRASE"
        return 0
    fi

    # Check if stdin is a TTY
    if [[ -t 0 ]]; then
        read -s -p "$prompt: " passphrase
        echo >&2
        echo "$passphrase"
    else
        # Not a TTY - try reading from /dev/tty directly
        if [[ -r /dev/tty ]]; then
            read -s -p "$prompt: " passphrase < /dev/tty
            echo >&2
            echo "$passphrase"
        else
            echo "Error: Cannot read passphrase - no TTY available" >&2
            echo "Options:" >&2
            echo "  1. Run from an interactive terminal" >&2
            echo "  2. Set VAULT_PASSPHRASE environment variable" >&2
            echo "  3. Use: ./tools/secret vault unlock --passphrase 'your-pass'" >&2
            return 1
        fi
    fi
}

# Helper: prompt for secret value
prompt_secret_value() {
    local value
    read -s -p "Enter secret value: " value
    echo >&2
    echo "$value"
}

# Helper: format JSON output or pretty print
format_output() {
    local json="$1"
    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$json"
    else
        echo "$json" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    if isinstance(data, dict):
        for k, v in data.items():
            if isinstance(v, (dict, list)):
                print(f'{k}: {json.dumps(v, indent=2)}')
            else:
                print(f'{k}: {v}')
    elif isinstance(data, list):
        for item in data:
            if isinstance(item, dict):
                print('---')
                for k, v in item.items():
                    print(f'  {k}: {v}')
            else:
                print(item)
    else:
        print(data)
except:
    print(sys.stdin.read())
" 2>/dev/null || echo "$json"
    fi
}

# Helper: lookup secret ID by name
lookup_secret_id() {
    local name="$1"
    local response
    response=$(api_request GET "/list")

    local id
    id=$(echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
secrets = data.get('secrets', [])
name = '$name'
for s in secrets:
    if s.get('name') == name:
        print(s.get('id'))
        break
" 2>/dev/null)

    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Secret '$name' not found${NC}" >&2
        exit 1
    fi

    echo "$id"
}

# Command: vault
cmd_vault() {
    local action="${1:-}"
    shift || true

    # Parse --passphrase flag if present
    local passphrase_arg=""
    local remaining_args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --passphrase)
                passphrase_arg="$2"
                shift 2
                ;;
            --passphrase=*)
                passphrase_arg="${1#*=}"
                shift
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    set -- "${remaining_args[@]}" 2>/dev/null || true

    case "$action" in
        init)
            echo -e "${BLUE}Initializing vault...${NC}"
            local passphrase
            if [[ -n "$passphrase_arg" ]]; then
                passphrase="$passphrase_arg"
            else
                passphrase=$(prompt_passphrase "Enter new vault passphrase") || exit 1
                local confirm
                confirm=$(prompt_passphrase "Confirm passphrase") || exit 1

                if [[ "$passphrase" != "$confirm" ]]; then
                    echo -e "${RED}Error: Passphrases do not match${NC}"
                    exit 1
                fi
            fi

            local data
            data=$(jq -n --arg passphrase "$passphrase" '{passphrase: $passphrase}')
            local response
            response=$(api_request POST "/vault/init" "$data")
            echo -e "${GREEN}Vault initialized successfully${NC}"
            format_output "$response"
            ;;

        unlock)
            local passphrase
            if [[ -n "$passphrase_arg" ]]; then
                passphrase="$passphrase_arg"
            else
                passphrase=$(prompt_passphrase "Enter vault passphrase") || exit 1
            fi

            local data
            data=$(jq -n --arg passphrase "$passphrase" '{passphrase: $passphrase}')
            local response
            response=$(api_request POST "/vault/unlock" "$data")
            echo -e "${GREEN}Vault unlocked${NC}"
            ;;

        lock)
            local response
            response=$(api_request POST "/vault/lock" "{}")
            echo -e "${GREEN}Vault locked${NC}"
            ;;

        status)
            local response
            response=$(api_request GET "/vault/status")
            format_output "$response"
            ;;

        recovery)
            # Recovery code management
            local recovery_action="${1:-}"
            shift || true

            case "$recovery_action" in
                generate)
                    local response
                    response=$(api_request POST "/vault/recovery/generate" "{}")
                    echo -e "${GREEN}New recovery codes generated:${NC}"
                    format_output "$response"
                    ;;
                use)
                    local code="${1:-}"
                    if [[ -z "$code" ]]; then
                        echo "Usage: secret vault recovery use <recovery-code>"
                        exit 1
                    fi
                    local new_passphrase
                    new_passphrase=$(prompt_passphrase "Enter new vault passphrase")
                    local confirm
                    confirm=$(prompt_passphrase "Confirm new passphrase")

                    if [[ "$new_passphrase" != "$confirm" ]]; then
                        echo -e "${RED}Error: Passphrases do not match${NC}"
                        exit 1
                    fi

                    local data
                    data=$(jq -n --arg code "$code" --arg pass "$new_passphrase" '{recoveryCode: $code, newPassphrase: $pass}')
                    local response
                    response=$(api_request POST "/vault/recovery/use" "$data")
                    echo -e "${GREEN}Vault reset with recovery code. All previous secrets have been deleted.${NC}"
                    ;;
                *)
                    echo "Usage: secret vault recovery <generate|use>"
                    exit 1
                    ;;
            esac
            ;;

        session)
            # Generate or manage session tokens
            local session_action="${1:-generate}"
            shift || true

            case "$session_action" in
                generate|"")
                    local name="${1:-}"
                    local data
                    if [[ -n "$name" ]]; then
                        data=$(jq -n --arg name "$name" '{name: $name}')
                    else
                        data="{}"
                    fi
                    local response
                    response=$(api_request POST "/vault/session" "$data")
                    # Extract just the token for easy capture
                    local token
                    token=$(echo "$response" | jq -r '.token')
                    if [[ "$JSON_OUTPUT" == "true" ]]; then
                        echo "$response"
                    else
                        echo "$token"
                    fi
                    ;;
                list)
                    local response
                    response=$(api_request GET "/vault/sessions")
                    format_output "$response"
                    ;;
                revoke)
                    local token="${1:-}"
                    if [[ -z "$token" ]]; then
                        echo "Usage: secret vault session revoke <token>"
                        exit 1
                    fi
                    local data
                    data=$(jq -n --arg token "$token" '{token: $token}')
                    local response
                    response=$(api_request POST "/vault/session/revoke" "$data")
                    echo -e "${GREEN}Session token revoked${NC}"
                    ;;
                *)
                    echo "Usage: secret vault session [generate|list|revoke]"
                    exit 1
                    ;;
            esac
            ;;

        *)
            echo "Usage: secret vault <init|unlock|lock|status|recovery|session>"
            exit 1
            ;;
    esac
}

# Command: create
cmd_create() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret create <name> [--type=...] [--service=...] [--description=...]"
        exit 1
    fi

    # Parse options
    local type="other"
    local service=""
    local description=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --type=*)
                type="${1#*=}"
                shift
                ;;
            --service=*)
                service="${1#*=}"
                shift
                ;;
            --description=*)
                description="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Prompt for secret value
    local value
    value=$(prompt_secret_value)

    # Build JSON payload using jq for safe value handling
    local data
    data=$(jq -n \
        --arg name "$name" \
        --arg value "$value" \
        --arg stype "$type" \
        --arg service "$service" \
        --arg description "$description" \
        '{
            name: $name,
            value: $value,
            secretType: $stype
        } + (if $service != "" then {serviceName: $service} else {} end)
          + (if $description != "" then {description: $description} else {} end)')

    local response
    response=$(api_request POST "/create" "$data")
    echo -e "${GREEN}Secret created: $name${NC}"
    format_output "$response"
}

# Command: list
cmd_list() {
    local service=""
    local type=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --service=*)
                service="${1#*=}"
                shift
                ;;
            --type=*)
                type="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    local response
    response=$(api_request GET "/list")

    # Filter if needed
    if [[ -n "$service" || -n "$type" ]]; then
        response=$(echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
secrets = data.get('secrets', [])
service_filter = '$service'
type_filter = '$type'

filtered = []
for s in secrets:
    if service_filter and s.get('service') != service_filter:
        continue
    if type_filter and s.get('type') != type_filter:
        continue
    filtered.append(s)

print(json.dumps({'secrets': filtered}))
")
    fi

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    else
        echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
secrets = data.get('secrets', [])
if not secrets:
    print('No secrets found')
else:
    print(f'Found {len(secrets)} secret(s):')
    print()
    for s in secrets:
        name = s.get('name', 'unknown')
        stype = s.get('type', 'other')
        service = s.get('service', '-')
        created = s.get('createdAt', '-')[:10] if s.get('createdAt') else '-'
        print(f'  {name}')
        print(f'    Type: {stype} | Service: {service} | Created: {created}')
"
    fi
}

# Command: get (fetch decrypted value)
cmd_get() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Usage: secret get <name>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    local response
    response=$(api_request GET "/fetch/$id")

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    else
        echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
value = data.get('value', '')
print(value)
"
    fi
}

# Command: show (metadata only)
cmd_show() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Usage: secret show <name>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    local response
    response=$(api_request GET "/get/$id")
    format_output "$response"
}

# Command: update
cmd_update() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret update <name> [--description=...]"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Parse options
    local description=""
    local service=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --description=*)
                description="${1#*=}"
                shift
                ;;
            --service=*)
                service="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Build JSON payload using jq for safe value handling
    local data
    data=$(jq -n \
        --arg description "$description" \
        --arg service "$service" \
        '(if $description != "" then {description: $description} else {} end)
         + (if $service != "" then {serviceName: $service} else {} end)')

    local response
    response=$(api_request POST "/update/$id" "$data")
    echo -e "${GREEN}Secret updated: $name${NC}"
    format_output "$response"
}

# Command: rotate
cmd_rotate() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Usage: secret rotate <name>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Prompt for new value
    local value
    value=$(prompt_secret_value)

    local data
    data=$(jq -n --arg newValue "$value" '{newValue: $newValue}')

    local response
    response=$(api_request POST "/rotate/$id" "$data")
    echo -e "${GREEN}Secret rotated: $name${NC}"
    format_output "$response"
}

# Command: delete
cmd_delete() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Usage: secret delete <name>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Confirm deletion
    read -p "Are you sure you want to delete '$name'? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled"
        exit 0
    fi

    local response
    response=$(api_request POST "/delete/$id" "{}")
    echo -e "${GREEN}Secret deleted: $name${NC}"
}

# Command: tag
cmd_tag() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret tag <name> --tool=<tool>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Parse options
    local tool=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --tool=*)
                tool="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$tool" ]]; then
        echo "Usage: secret tag <name> --tool=<tool>"
        exit 1
    fi

    local data
    data=$(jq -n --arg tagValue "$tool" '{tagType: "tool", tagValue: $tagValue}')

    local response
    response=$(api_request POST "/tag/$id" "$data")
    echo -e "${GREEN}Tag 'tool:$tool' added to $name${NC}"
}

# Command: untag
cmd_untag() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret untag <name> --tool=<tool>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Parse options
    local tool=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --tool=*)
                tool="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$tool" ]]; then
        echo "Usage: secret untag <name> --tool=<tool>"
        exit 1
    fi

    local data
    data=$(jq -n --arg tagValue "$tool" '{tagType: "tool", tagValue: $tagValue}')

    local response
    response=$(api_request POST "/untag/$id" "$data")
    echo -e "${GREEN}Tag 'tool:$tool' removed from $name${NC}"
}

# Command: grant
cmd_grant() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret grant <name> --to=<identity> --permission=<perm>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Parse options
    local to=""
    local permission="read"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --to=*)
                to="${1#*=}"
                shift
                ;;
            --permission=*)
                permission="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$to" ]]; then
        echo "Usage: secret grant <name> --to=<identity> --permission=<perm>"
        echo "Example: secret grant my-secret --to=agent:housekeeping --permission=read"
        exit 1
    fi

    # Parse identity into type and name (e.g., "agent:housekeeping")
    local grantee_type grantee_name
    grantee_type="${to%%:*}"
    grantee_name="${to#*:}"

    if [[ "$grantee_type" != "agent" && "$grantee_type" != "principal" ]]; then
        echo -e "${RED}Error: Identity must start with 'agent:' or 'principal:'${NC}"
        exit 1
    fi

    local data
    data=$(jq -n \
        --arg granteeType "$grantee_type" \
        --arg granteeName "$grantee_name" \
        --arg permission "$permission" \
        '{granteeType: $granteeType, granteeName: $granteeName, permission: $permission}')

    local response
    response=$(api_request POST "/grant/$id" "$data")
    echo -e "${GREEN}Granted '$permission' access to '$to' for $name${NC}"
}

# Command: revoke
cmd_revoke() {
    local name="${1:-}"
    shift || true

    if [[ -z "$name" ]]; then
        echo "Usage: secret revoke <name> --from=<identity>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    # Parse options
    local from=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --from=*)
                from="${1#*=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$from" ]]; then
        echo "Usage: secret revoke <name> --from=<identity>"
        echo "Example: secret revoke my-secret --from=agent:housekeeping"
        exit 1
    fi

    # Parse identity into type and name (e.g., "agent:housekeeping")
    local grantee_type grantee_name
    grantee_type="${from%%:*}"
    grantee_name="${from#*:}"

    if [[ "$grantee_type" != "agent" && "$grantee_type" != "principal" ]]; then
        echo -e "${RED}Error: Identity must start with 'agent:' or 'principal:'${NC}"
        exit 1
    fi

    local data
    data=$(jq -n \
        --arg granteeType "$grantee_type" \
        --arg granteeName "$grantee_name" \
        '{granteeType: $granteeType, granteeName: $granteeName}')

    local response
    response=$(api_request POST "/revoke/$id" "$data")
    echo -e "${GREEN}Revoked access from '$from' for $name${NC}"
}

# Command: audit
cmd_audit() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Usage: secret audit <name>"
        exit 1
    fi

    local id
    id=$(lookup_secret_id "$name")

    local response
    response=$(api_request GET "/audit/$id")

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    else
        echo -e "${CYAN}Audit log for: $name${NC}"
        echo
        echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
entries = data.get('entries', [])
if not entries:
    print('No audit entries found')
else:
    for e in entries:
        ts = e.get('timestamp', '-')[:19].replace('T', ' ')
        action = e.get('action', '-')
        actor = e.get('actor', '-')
        details = e.get('details', '')
        print(f'  [{ts}] {action} by {actor}')
        if details:
            print(f'    {details}')
"
    fi
}

# Main command dispatch
main() {
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    COMMAND="${1:-}"
    shift || true

    case "$COMMAND" in
        vault)
            cmd_vault "$@"
            ;;
        create)
            cmd_create "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        get)
            cmd_get "$@"
            ;;
        show)
            cmd_show "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        rotate)
            cmd_rotate "$@"
            ;;
        delete)
            cmd_delete "$@"
            ;;
        tag)
            cmd_tag "$@"
            ;;
        untag)
            cmd_untag "$@"
            ;;
        grant)
            cmd_grant "$@"
            ;;
        revoke)
            cmd_revoke "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        ""|help|--help|-h)
            head -50 "$0" | tail -49 | sed 's/^# //' | sed 's/^#//'
            trap - EXIT
            log_end "$RUN_ID" "success" 0 0 "Help displayed" 2>/dev/null || true
            exit 0
            ;;
        *)
            log_error "Unknown command: $COMMAND"
            echo "Use: ./tools/secret --help"
            trap - EXIT
            log_end "$RUN_ID" "failure" 1 0 "Unknown command" 2>/dev/null || true
            exit 1
            ;;
    esac

    trap - EXIT
    log_end "$RUN_ID" "success" 0 0 "Command completed: $COMMAND" 2>/dev/null || true
}

main "$@"
