#!/bin/bash
# Restore session - apply backed-up changes to working directory
#
# Usage: ./tools/restore [--verbose]
#
# Why this exists:
#   Manually restore uncommitted and staged changes from previous session
#   Enables session continuity after backup

set -e

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "restore" "agency-tool" "$@" 2>/dev/null) || true

# Tool version
TOOL_VERSION="1.0.0-20260114-000006"

# Defaults
VERBOSE=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions (quiet by default)
log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Main function
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --version|-v)
                echo "restore $TOOL_VERSION"
                exit 0
                ;;
            --help|-h)
                echo "restore - Restore session from backup"
                echo ""
                echo "Usage:"
                echo "  ./tools/restore [--verbose]"
                echo ""
                echo "Options:"
                echo "  --verbose     Show detailed logging"
                echo "  --version, -v Show tool version"
                echo "  --help, -h    Show this help"
                exit 0
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    verbose_echo "restore [run: ${RUN_ID:-none}]"

    local AGENTNAME=$(./tools/agentname 2>/dev/null || echo 'unknown')
    local BACKUP_DIR="claude/agents/$AGENTNAME/backups/latest"
    local UNCOMMITTED_PATCH="$BACKUP_DIR/uncommitted.patch"
    local STAGED_PATCH="$BACKUP_DIR/staged.patch"

    log_step "Checking for session backup"
    if [ ! -d "$BACKUP_DIR" ]; then
        echo "âŒ No session backup found" >&2
        echo "   Nothing to restore." >&2
        trap - EXIT
        log_end "$RUN_ID" "failure" 1 0 "No backup found"
        exit 1
    fi

    echo "ðŸ”„ Restoring session..." >&2

    # Apply uncommitted changes
    log_step "Checking for uncommitted changes"
    if [ -f "$UNCOMMITTED_PATCH" ]; then
        verbose_echo "   Applying uncommitted changes..." >&2
        if git apply "$UNCOMMITTED_PATCH" 2>/dev/null; then
            echo "   âœ… Uncommitted changes restored" >&2
        else
            echo "   âš ï¸  Could not apply uncommitted changes (conflicts?)" >&2
            echo "   Patch saved at: $UNCOMMITTED_PATCH" >&2
            echo "   You can manually apply with: git apply $UNCOMMITTED_PATCH" >&2
        fi
    else
        verbose_echo "   â€¢ No uncommitted changes to restore" >&2
    fi

    # Apply staged changes
    log_step "Checking for staged changes"
    if [ -f "$STAGED_PATCH" ]; then
        verbose_echo "   Applying staged changes..." >&2
        if git apply --cached "$STAGED_PATCH" 2>/dev/null; then
            echo "   âœ… Staged changes restored" >&2
        else
            echo "   âš ï¸  Could not apply staged changes (conflicts?)" >&2
            echo "   Patch saved at: $STAGED_PATCH" >&2
            echo "   You can manually apply with: git apply --cached $STAGED_PATCH" >&2
        fi
    else
        verbose_echo "   â€¢ No staged changes to restore" >&2
    fi

    echo "" >&2
    echo "âœ… Restore complete" >&2
    verbose_echo "" >&2

    # Show current git status
    verbose_echo "Current status:" >&2
    git status --short

    trap - EXIT  # Clear trap
    log_end "$RUN_ID" "success" 0 0 "Restore complete" 2>/dev/null || true
}

main "$@"
