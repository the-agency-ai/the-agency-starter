#!/bin/bash
#
# version-next - Calculate the next version number
#
# Usage:
#   ./tools/version-next                     # Read VERSION file, output next
#   ./tools/version-next 1.0.0-20260110-000001  # Output: 1.0.0-20260110-000002
#   ./tools/version-next --major             # Increment major version
#   ./tools/version-next --minor             # Increment minor version
#   ./tools/version-next --patch             # Increment patch version
#   ./tools/version-next --build             # Increment build only (default)
#   ./tools/version-next --apply             # Update VERSION file in place
#
# Version Format: MAJOR.MINOR.PATCH-YYYYMMDD-NNNNNN
#   MAJOR    - Breaking changes
#   MINOR    - New features (backward compatible)
#   PATCH    - Bug fixes (backward compatible)
#   YYYYMMDD - Build date
#   NNNNNN   - Build number (6 digits, resets on date change)
#

set -euo pipefail

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "version-next" "agency-tool" "$@" 2>/dev/null) || true

TOOL_VERSION="1.0.0-20260110-000001"

# ============================================================================
# Logging
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Find VERSION file - check multiple locations
find_version_file() {
    local locations=(
        "./VERSION"
        "../VERSION"
        "$(git rev-parse --show-toplevel 2>/dev/null)/VERSION"
        "$SCRIPT_DIR/../VERSION"
        "$SCRIPT_DIR/../the-agency-starter/VERSION"
    )

    for loc in "${locations[@]}"; do
        if [[ -f "$loc" ]]; then
            echo "$loc"
            return 0
        fi
    done

    return 1
}

# ============================================================================
# Version Parsing
# ============================================================================

parse_version() {
    local version="$1"

    # Match: MAJOR.MINOR.PATCH-YYYYMMDD-NNNNNN
    if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)-([0-9]{8})-([0-9]{6})$ ]]; then
        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        PATCH="${BASH_REMATCH[3]}"
        DATE="${BASH_REMATCH[4]}"
        BUILD="${BASH_REMATCH[5]}"
        return 0
    fi

    # Match: MAJOR.MINOR.PATCH (legacy format - upgrade to new)
    if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        PATCH="${BASH_REMATCH[3]}"
        DATE="$(date +%Y%m%d)"
        BUILD="000001"
        return 0
    fi

    return 1
}

format_version() {
    printf "%d.%d.%d-%s-%06d" "$MAJOR" "$MINOR" "$PATCH" "$DATE" "$((10#$BUILD))"
}

# ============================================================================
# Version Increment
# ============================================================================

increment_build() {
    local today
    today="$(date +%Y%m%d)"

    if [[ "$DATE" != "$today" ]]; then
        # New day, reset build number
        DATE="$today"
        BUILD="000001"
    else
        # Same day, increment build
        BUILD=$(printf "%06d" "$((10#$BUILD + 1))")
    fi
}

increment_patch() {
    PATCH=$((PATCH + 1))
    DATE="$(date +%Y%m%d)"
    BUILD="000001"
}

increment_minor() {
    MINOR=$((MINOR + 1))
    PATCH=0
    DATE="$(date +%Y%m%d)"
    BUILD="000001"
}

increment_major() {
    MAJOR=$((MAJOR + 1))
    MINOR=0
    PATCH=0
    DATE="$(date +%Y%m%d)"
    BUILD="000001"
}

# ============================================================================
# Help
# ============================================================================

print_help() {
    cat << 'EOF'
version-next - Calculate the next version number

USAGE:
    ./tools/version-next [OPTIONS] [VERSION]

OPTIONS:
    --major         Increment major version (resets minor, patch, build)
    --minor         Increment minor version (resets patch, build)
    --patch         Increment patch version (resets build)
    --build, -b     Increment build only (default)
    --apply, -a     Update VERSION file in place
    --file FILE     Use specific VERSION file
    --help, -h      Show this help message
    --version, -v   Show version

VERSION FORMAT:
    MAJOR.MINOR.PATCH-YYYYMMDD-NNNNNN

    Example: 1.0.0-20260110-000001
             │ │ │    │       │
             │ │ │    │       └── Build number (resets daily)
             │ │ │    └────────── Build date
             │ │ └─────────────── Patch (bug fixes)
             │ └───────────────── Minor (new features)
             └─────────────────── Major (breaking changes)

EXAMPLES:
    ./tools/version-next                          # Next build from VERSION file
    ./tools/version-next 1.0.0-20260110-000001    # Output: 1.0.0-20260110-000002
    ./tools/version-next --minor                  # Next minor version
    ./tools/version-next --apply                  # Update VERSION file
    ./tools/version-next --major --apply          # Major release, update file

BEHAVIOR:
    - Build number resets to 000001 on each new day
    - Patch/minor/major bumps reset build to 000001
    - Date always updates to today when incrementing version component
    - Legacy versions (0.3.1) are upgraded to new format
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    local increment_type="build"
    local apply=false
    local version_file=""
    local input_version=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --version|-v)
                echo "version-next $TOOL_VERSION"
                exit 0
                ;;
            --help|-h)
                print_help
                exit 0
                ;;
            --major)
                increment_type="major"
                shift
                ;;
            --minor)
                increment_type="minor"
                shift
                ;;
            --patch)
                increment_type="patch"
                shift
                ;;
            --build|-b)
                increment_type="build"
                shift
                ;;
            --apply|-a)
                apply=true
                shift
                ;;
            --file)
                version_file="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                input_version="$1"
                shift
                ;;
        esac
    done

    # Get current version
    if [[ -n "$input_version" ]]; then
        # Version provided as argument
        current_version="$input_version"
    else
        # Read from VERSION file
        if [[ -z "$version_file" ]]; then
            version_file=$(find_version_file) || {
                log_error "VERSION file not found"
                exit 1
            }
        fi

        if [[ ! -f "$version_file" ]]; then
            log_error "VERSION file not found: $version_file"
            exit 1
        fi

        current_version=$(cat "$version_file" | tr -d '[:space:]')
    fi

    # Parse current version
    if ! parse_version "$current_version"; then
        log_error "Invalid version format: $current_version"
        log_error "Expected: MAJOR.MINOR.PATCH-YYYYMMDD-NNNNNN"
        exit 1
    fi

    # Increment version
    case $increment_type in
        major)
            increment_major
            ;;
        minor)
            increment_minor
            ;;
        patch)
            increment_patch
            ;;
        build)
            increment_build
            ;;
    esac

    # Format new version
    new_version=$(format_version)

    # Apply to file if requested
    if [[ "$apply" == "true" ]]; then
        if [[ -z "$version_file" ]]; then
            version_file=$(find_version_file) || {
                log_error "VERSION file not found for --apply"
                exit 1
            }
        fi

        echo "$new_version" > "$version_file"
        log_info "Updated $version_file: $current_version -> $new_version"
    fi

    # Output new version
    echo "$new_version"
}

main "$@"
