#!/bin/bash
# starter-release - Cut a release of the-agency-starter
#
# Usage:
#   ./tools/starter-release [version]
#   ./tools/starter-release 1.0.0          # Specific version
#   ./tools/starter-release patch          # Auto-increment patch (0.1.0 -> 0.1.1)
#   ./tools/starter-release minor          # Auto-increment minor (0.1.0 -> 0.2.0)
#   ./tools/starter-release major          # Auto-increment major (0.1.0 -> 1.0.0)
#   ./tools/starter-release --dry-run      # Show what would happen
#
# This tool:
# 1. Syncs files from the-agency to the-agency-starter
# 2. Cleans up cruft (logs, data, .DS_Store)
# 3. Runs verification checks
# 4. Commits and tags the release
# 5. Updates history/releases.md

set -e

# Source log helper for telemetry
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [[ -f "$SCRIPT_DIR/_log-helper" ]]; then
    source "$SCRIPT_DIR/_log-helper"
fi
RUN_ID=$(log_start "starter-release" "agency-tool" "$@" 2>/dev/null) || true

# Tool version
TOOL_VERSION="1.0.0-20260110-000001"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { [[ "$VERBOSE" == "true" ]] && echo -e "${GREEN}[INFO]${NC} $1" || true; }
log_warn() { [[ "$VERBOSE" == "true" ]] && echo -e "${YELLOW}[WARN]${NC} $1" || true; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }  # Always show errors
log_step() { [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[STEP]${NC} $1" || true; }
verbose_echo() { [[ "$VERBOSE" == "true" ]] && echo "$@" || true; }

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
# Starter is now a sibling repo, not a subdirectory
STARTER_DIR="$(cd "$PROJECT_ROOT/../the-agency-starter" 2>/dev/null && pwd)"
if [[ -z "$STARTER_DIR" || ! -d "$STARTER_DIR" ]]; then
    # Fallback to environment variable or error
    STARTER_DIR="${THE_AGENCY_STARTER_DIR:-}"
fi
VERSION_FILE="$STARTER_DIR/VERSION"

# Parse arguments
DRY_RUN=false
SYNC_ONLY=false
VERBOSE=false
VERSION_ARG=""

for arg in "$@"; do
    case $arg in
        --dry-run|-n)
            DRY_RUN=true
            ;;
        --sync-only|-s)
            SYNC_ONLY=true
            ;;
        --verbose)
            VERBOSE=true
            ;;
        --version|-v)
            echo "starter-release $TOOL_VERSION"
            exit 0
            ;;
        --help|-h)
            echo "starter-release - Cut a release of the-agency-starter"
            echo ""
            echo "Usage:"
            echo "  ./tools/starter-release [version]"
            echo "  ./tools/starter-release 1.0.0          # Specific version"
            echo "  ./tools/starter-release patch          # Auto-increment patch"
            echo "  ./tools/starter-release minor          # Auto-increment minor"
            echo "  ./tools/starter-release major          # Auto-increment major"
            echo "  ./tools/starter-release --sync-only    # Sync files without release"
            echo "  ./tools/starter-release --dry-run      # Show what would happen"
            echo ""
            echo "Options:"
            echo "  --sync-only, -s  Sync files only (no version, commit, or tag)"
            echo "  --dry-run, -n    Show what would happen without making changes"
            echo "  --version, -v    Show tool version"
            echo "  --help, -h       Show this help"
            exit 0
            ;;
        *)
            VERSION_ARG="$arg"
            ;;
    esac
done

# Get current version
get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "0.0.0"
    fi
}

# Bump version based on type
bump_version() {
    local current="$1"
    local type="$2"

    IFS='.' read -r major minor patch <<< "$current"

    case "$type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "${major}.$((minor + 1)).0"
            ;;
        patch)
            echo "${major}.${minor}.$((patch + 1))"
            ;;
        *)
            echo "$type"  # Assume it's a specific version
            ;;
    esac
}

# Sync files from the-agency to starter
sync_files() {
    log_step "Syncing files to the-agency-starter..."

    # Files/directories to sync (EXCLUDES private content)
    # NOTE: claude/principals is NOT synced - starter has its own sanitized structure
    local sync_items=(
        ".claude/settings.json"
        ".claude/settings.local.json.example"
        ".claude/hooks"
        ".claude/commands"
        ".gitignore"
        "CLAUDE.md"
        "LICENSE"
        "README.md"
        "claude/agents/captain/agent.md"
        "claude/agents/captain/KNOWLEDGE.md"
        "claude/agents/captain/WORKLOG.md"
        "claude/agents/captain/ADHOC-WORKLOG.md"
        "claude/agents/collaboration"
        "claude/config"
        "claude/docs/TERMINAL-INTEGRATION.md"
        "claude/docs/PERMISSIONS.md"
        "claude/docs/SECRETS.md"
        "claude/docs/REPO-RELATIONSHIP.md"
        "claude/docs/FIRST-LAUNCH.md"
        "claude/docs/FIRST-LAUNCH-CONTEXT.jsonl"
        "claude/docs/STARTER-PACK-INTEGRATION.md"
        "claude/docs/INDEX.md"
        "claude/docs/cookbooks"
        "claude/docs/tutorials"
        "claude/integrations"
        "claude/knowledge"
        "claude/proposals"
        "claude/templates"
        "claude/workstreams"
        "tools"
        "source/apps/agency-bench"
        "source/services/agency-service"
    )

    # Create necessary directories
    mkdir -p "$STARTER_DIR/claude"
    mkdir -p "$STARTER_DIR/claude/data"
    mkdir -p "$STARTER_DIR/claude/logs"
    mkdir -p "$STARTER_DIR/claude/agents/captain"
    mkdir -p "$STARTER_DIR/source/apps"
    mkdir -p "$STARTER_DIR/source/services"

    # Sync each item
    for item in "${sync_items[@]}"; do
        local src="$PROJECT_ROOT/$item"
        local dest="$STARTER_DIR/$item"

        if [[ -e "$src" ]]; then
            # Create parent directory if needed
            mkdir -p "$(dirname "$dest")"

            if [[ -d "$src" ]]; then
                rsync -a --delete "$src/" "$dest/"
            else
                cp "$src" "$dest"
            fi
            verbose_echo "  Synced: $item"
        else
            log_warn "Missing: $item"
        fi
    done

    # Create .gitkeep files for empty directories
    touch "$STARTER_DIR/claude/data/.gitkeep"
    touch "$STARTER_DIR/claude/logs/.gitkeep"

    # Clean up sensitive content that might have been synced
    log_step "Cleaning sensitive content..."
    rm -rf "$STARTER_DIR/claude/agents/captain/SESSION-"* 2>/dev/null || true
    rm -rf "$STARTER_DIR/claude/agents/captain/backups" 2>/dev/null || true
    rm -rf "$STARTER_DIR/claude/principals/jordan" 2>/dev/null || true
    rm -f "$STARTER_DIR/claude/principals/"*/resources/secrets/* 2>/dev/null || true
    verbose_echo "  Cleaned sensitive content"
}

# Clean up cruft
clean_cruft() {
    log_step "Cleaning up cruft..."

    # Remove patterns
    find "$STARTER_DIR" -name ".DS_Store" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.log" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db-wal" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.db-shm" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "*.pid" -delete 2>/dev/null || true
    find "$STARTER_DIR" -name "node_modules" -type d -exec rm -rf {} + 2>/dev/null || true
    # NOTE: .claude directory is now preserved (contains settings.json and hooks)

    # Remove specific files that shouldn't be in starter
    rm -f "$STARTER_DIR/history/push-log.md" 2>/dev/null || true
    rm -f "$STARTER_DIR/history/releases.md" 2>/dev/null || true

    # Clean build artifacts from apps (but keep source)
    rm -rf "$STARTER_DIR/source/apps/agency-bench/src-tauri/target" 2>/dev/null || true
    rm -rf "$STARTER_DIR/source/apps/agency-bench/.next" 2>/dev/null || true
    rm -rf "$STARTER_DIR/source/apps/agency-bench/out" 2>/dev/null || true

    # Clean build artifacts from services (but keep source)
    rm -rf "$STARTER_DIR/source/services/agency-service/node_modules" 2>/dev/null || true
    rm -rf "$STARTER_DIR/source/services/agency-service/logs" 2>/dev/null || true

    # Scrub sensitive identifiers from config if synced
    if [[ -f "$STARTER_DIR/claude/config/agency.yaml" ]]; then
        # Remove jdm: jordan line if present
        sed -i '' '/jdm: jordan/d' "$STARTER_DIR/claude/config/agency.yaml" 2>/dev/null || true
    fi

    echo "  Cleaned cruft"
}

# Verify the build
verify_build() {
    log_step "Verifying build..."

    local errors=0

    # Required files
    local required_files=(
        ".claude/settings.json"
        ".claude/settings.local.json.example"
        ".gitignore"
        "CLAUDE.md"
        "README.md"
        "tools/myclaude"
        "tools/welcomeback"
        "tools/agent-create"
        "tools/workstream-create"
        "tools/tab-status"
        "tools/session-backup"
        "claude/config/agency.yaml"
        "claude/agents/captain/agent.md"
        "source/apps/agency-bench/package.json"
        "source/apps/agency-bench/src-tauri/tauri.conf.json"
        "source/services/agency-service/package.json"
        "source/services/agency-service/src/index.ts"
    )

    for file in "${required_files[@]}"; do
        if [[ ! -f "$STARTER_DIR/$file" ]]; then
            log_error "Missing required file: $file"
            ((errors++))
        else
            echo "  ✓ $file"
        fi
    done

    # Check tools are executable
    for tool in "$STARTER_DIR/tools/"*; do
        if [[ -f "$tool" && ! -x "$tool" ]]; then
            log_warn "Tool not executable: $(basename "$tool")"
            chmod +x "$tool"
            echo "  Fixed: $(basename "$tool")"
        fi
    done

    # Check for secrets using comprehensive scanner
    log_step "Scanning for secrets..."
    if [[ -x "$STARTER_DIR/tools/secrets-scan" ]]; then
        if ! "$STARTER_DIR/tools/secrets-scan" 2>/dev/null; then
            log_error "Secrets detected in starter!"
            ((errors++))
        else
            echo "  ✓ No secrets detected"
        fi
    else
        # Fallback to comprehensive grep patterns if scanner not available
        local secret_patterns=(
            "GUMROAD_[A-Z_]*=[A-Za-z0-9_-]\\{20,\\}"
            "sk-ant-[A-Za-z0-9_-]\\{20,\\}"
            "ghp_[A-Za-z0-9]\\{36\\}"
            "gho_[A-Za-z0-9]\\{36\\}"
            "ANTHROPIC_API_KEY"
            "OPENAI_API_KEY"
            "client_secret.*=.*[A-Za-z0-9_-]\\{20,\\}"
            "access_token.*=.*[A-Za-z0-9_-]\\{20,\\}"
            "-----BEGIN.*PRIVATE KEY-----"
        )
        local found_secrets=false
        for pattern in "${secret_patterns[@]}"; do
            if grep -rE "$pattern" "$STARTER_DIR" --include="*.yaml" --include="*.json" --include="*.env" --include="*.ts" --include="*.sh" 2>/dev/null; then
                found_secrets=true
            fi
        done
        if [[ "$found_secrets" == "true" ]]; then
            log_error "Potential secrets found in starter!"
            ((errors++))
        else
            echo "  ✓ No obvious secrets"
        fi
    fi

    # Check for jordan principal directory (should never be in starter)
    if [[ -d "$STARTER_DIR/claude/principals/jordan" ]]; then
        log_error "jordan principal found in starter! This should NOT be synced."
        ((errors++))
    else
        echo "  ✓ No private principals"
    fi

    # Check for large files (>1MB)
    local large_files
    large_files=$(find "$STARTER_DIR" -type f -size +1M 2>/dev/null)
    if [[ -n "$large_files" ]]; then
        log_warn "Large files found:"
        echo "$large_files"
    else
        echo "  ✓ No large files"
    fi

    if [[ $errors -gt 0 ]]; then
        log_error "Verification failed with $errors error(s)"
        return 1
    fi

    log_info "Verification passed"
}

# Update CHANGELOG.md in starter
update_changelog() {
    local version="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d')

    log_step "Updating CHANGELOG.md in starter..."

    local changelog="$STARTER_DIR/CHANGELOG.md"
    if [[ -f "$changelog" ]]; then
        # Prepend release entry after the header
        local temp_file
        temp_file=$(mktemp)

        cat > "$temp_file" << EOF
## [$version] - $timestamp

- Synced from the-agency
- See GitHub release for details

EOF

        # Keep first 2 lines (header), insert new entry, then rest
        {
            head -n 2 "$changelog"
            echo ""
            cat "$temp_file"
            tail -n +3 "$changelog"
        } > "${changelog}.new"

        mv "${changelog}.new" "$changelog"
        rm -f "$temp_file"

        echo "  Updated: CHANGELOG.md"
    fi
}

# Commit and tag in the starter repo
commit_and_tag() {
    local version="$1"

    log_step "Committing and tagging in starter repo..."

    cd "$STARTER_DIR"

    # Stage all changes
    git add -A

    # Commit
    git commit -m "release: the-agency-starter v$version

Synced from the-agency and prepared for release.

Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude <noreply@anthropic.com>"

    # Tag
    git tag -a "v$version" -m "the-agency-starter v$version"

    echo "  Created commit and tag: v$version"

    # Return to original directory
    cd "$PROJECT_ROOT"
}

# Main
main() {
    # Trap unexpected exits
    trap 'log_end "$RUN_ID" "failure" $? 0 "Unexpected exit" 2>/dev/null || true' EXIT

    echo "starter-release [run: ${RUN_ID:-none}]"

    # Check starter directory exists
    if [[ -z "$STARTER_DIR" || ! -d "$STARTER_DIR" ]]; then
        log_error "Starter directory not found"
        echo ""
        echo "Expected at: $(cd "$PROJECT_ROOT/.." && pwd)/the-agency-starter"
        echo "Or set THE_AGENCY_STARTER_DIR environment variable"
        trap - EXIT  # Clear trap
        log_end "$RUN_ID" "failure" 1 0 "Starter directory not found"
        exit 1
    fi

    log_info "Using starter directory: $STARTER_DIR"

    # Determine version
    local current_version
    current_version=$(get_current_version)

    # Handle sync-only mode
    if [[ "$SYNC_ONLY" == "true" ]]; then
        log_info "Current version: $current_version"
        log_info "Mode: sync-only (no version change)"
        echo ""

        # Execute sync only
        sync_files
        echo ""

        clean_cruft
        echo ""

        verify_build
        echo ""

        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        log_info "Sync complete (no version change)"
        echo ""
        echo "To cut a release, run:"
        echo "  ./tools/starter-release patch"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        trap - EXIT  # Clear trap
        log_end "$RUN_ID" "success" 0 0 "Sync complete (sync-only mode)"
        exit 0
    fi

    local new_version
    if [[ -z "$VERSION_ARG" ]]; then
        new_version=$(bump_version "$current_version" "patch")
    else
        new_version=$(bump_version "$current_version" "$VERSION_ARG")
    fi

    log_info "Current version: $current_version"
    log_info "New version: $new_version"
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warn "DRY RUN - No changes will be made"
        echo ""

        log_step "Would sync files..."
        log_step "Would clean cruft..."
        log_step "Would verify build..."
        log_step "Would update VERSION to $new_version..."
        log_step "Would update CHANGELOG.md..."
        log_step "Would commit and tag as v$new_version..."

        echo ""
        log_info "Dry run complete. Run without --dry-run to execute."
        trap - EXIT  # Clear trap
        log_end "$RUN_ID" "success" 0 0 "Dry run complete (no changes made)"
        exit 0
    fi

    # Execute release
    sync_files
    echo ""

    clean_cruft
    echo ""

    verify_build
    echo ""

    # Write version file
    log_step "Writing version file..."
    echo "$new_version" > "$VERSION_FILE"
    echo "  VERSION: $new_version"
    echo ""

    update_changelog "$new_version"
    echo ""

    commit_and_tag "$new_version"
    echo ""

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_info "Release complete: v$new_version"
    echo ""
    echo "Next steps (in starter repo):"
    echo "  cd $STARTER_DIR"
    echo "  git push origin main"
    echo "  git push origin v$new_version"
    echo ""
    echo "Or create GitHub release:"
    echo "  gh release create v$new_version --generate-notes"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    trap - EXIT  # Clear trap
    log_end "$RUN_ID" "success" 0 0 "Release v$new_version complete"
}

main
