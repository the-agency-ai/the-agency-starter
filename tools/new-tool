#!/bin/bash
# new-tool - Create a new tool from template
#
# Usage:
#   ./tools/new-tool <name> "<description>"
#
# Creates a new tool that:
# - Uses context-efficient logging (1-line output)
# - Logs details to log-service
# - Supports --verbose for immediate output
# - Returns run-id for debugging

set -e

# Tool version
TOOL_VERSION="1.0.0-20260110-000001"

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
TEMPLATE_FILE="$PROJECT_ROOT/claude/templates/TOOL.sh"
TOOLS_DIR="$PROJECT_ROOT/tools"
BUILD_FILE="$PROJECT_ROOT/claude/data/tool-build-number"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Get next build number (monotonically increasing)
get_next_build() {
    mkdir -p "$(dirname "$BUILD_FILE")"

    if [[ -f "$BUILD_FILE" ]]; then
        local current
        current=$(cat "$BUILD_FILE")
        local next=$((current + 1))
        echo "$next" > "$BUILD_FILE"
        echo "$next"
    else
        echo "1" > "$BUILD_FILE"
        echo "1"
    fi
}

# Main
main() {
    local tool_name="$1"
    local tool_description="${2:-A new tool}"

    if [[ -z "$tool_name" ]]; then
        echo "new-tool - Create a new tool from template"
        echo ""
        echo "Usage:"
        echo "  ./tools/new-tool <name> \"<description>\""
        echo ""
        echo "Example:"
        echo "  ./tools/new-tool sync-data \"Sync data between environments\""
        exit 1
    fi

    # Validate name
    if [[ ! "$tool_name" =~ ^[a-z][a-z0-9-]*$ ]]; then
        log_error "Tool name must be lowercase, start with letter, contain only letters, numbers, hyphens"
        exit 1
    fi

    # Check if tool already exists
    local tool_file="$TOOLS_DIR/$tool_name"
    if [[ -f "$tool_file" ]]; then
        log_error "Tool already exists: $tool_file"
        exit 1
    fi

    # Check template exists
    if [[ ! -f "$TEMPLATE_FILE" ]]; then
        log_error "Template not found: $TEMPLATE_FILE"
        exit 1
    fi

    # Get build number and date
    local build_number
    build_number=$(get_next_build)
    local tool_date
    tool_date=$(date '+%Y%m%d')

    # Generate tool
    log_info "Creating tool: $tool_name"

    sed \
        -e "s/{{TOOL_NAME}}/$tool_name/g" \
        -e "s/{{TOOL_DESCRIPTION}}/$tool_description/g" \
        -e "s/{{BUILD_NUMBER}}/$build_number/g" \
        "$TEMPLATE_FILE" > "$tool_file"

    chmod +x "$tool_file"

    log_info "Created: $tool_file"
    log_info "Build: $build_number"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $tool_file and add your logic"
    echo "  2. Test with: ./tools/$tool_name --verbose"
    echo "  3. Test logging: ./tools/$tool_name"
}

case "${1:-}" in
    --version|-v)
        echo "new-tool $TOOL_VERSION"
        ;;
    --help|-h)
        echo "new-tool - Create a new tool from template"
        echo ""
        echo "Usage:"
        echo "  ./tools/new-tool <name> \"<description>\""
        echo ""
        echo "Creates a tool that uses context-efficient logging:"
        echo "  - Single-line output (SUCCESS/FAILURE + run-id)"
        echo "  - Details logged to log-service"
        echo "  - Debug with: ./tools/agency-service log run <run-id>"
        ;;
    *)
        main "$@"
        ;;
esac
